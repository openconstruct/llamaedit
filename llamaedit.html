<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LLamaEdit</title>

  <!-- CodeMirror Core -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>

  <!-- CodeMirror Addons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/dialog/dialog.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/search/search.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/search/searchcursor.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/dialog/dialog.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/matchbrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/closebrackets.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/javascript-hint.min.js"></script>

  <!-- CodeMirror Modes -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/javascript/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/htmlmixed/htmlmixed.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/css/css.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/xml/xml.min.js"></script>

  <!-- CodeMirror Themes -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/dracula.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/material.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/monokai.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/eclipse.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/base16-light.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/solarized.min.css">


  <style>
    /* General Styles */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #282a36; /* Default: Dracula background */
      color: #f8f8f2;       /* Default: Dracula foreground */
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      transition: background-color 0.3s, color 0.3s; /* Smooth theme transitions */
    }

    /* Layout Containers */
    .navbar, .toolbar, .find-replace-container, .status-bar {
      flex-shrink: 0; /* Prevent shrinking */
    }
    .editor-container {
      flex: 1;
      display: flex;
      min-height: 0;
    }
    .sidebar {
      width: 200px;
      background-color: #353746;
      padding: 10px;
      overflow-y: auto;
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
    }
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }
    #editor {
        flex: 1;
        position: relative;
        overflow: hidden;
        min-height: 0;
    }

    /* Navbar */
    .navbar {
      background-color: #44475a;
      padding: 10px 15px; /* Slightly more padding */
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .brand {
      font-size: 1.5rem;
      font-weight: bold;
      color: #bd93f9;
    }

    /* Toolbar */
    .toolbar {
      display: flex;
      gap: 8px; /* Slightly reduced gap */
      background-color: #373a49;
      padding: 8px 15px; /* Match navbar horizontal padding */
      align-items: center; /* Align items vertically */
    }

    /* General Button Styling */
    button {
      background-color: #50fa7b;
      color: #282a36;
      border: none;
      padding: 6px 12px; /* Default padding */
      border-radius: 4px;  /* Default rounding */
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.2s, opacity 0.2s;
      font-size: 0.9rem; /* Standardize font size */
      line-height: 1.2; /* Ensure text is centered */
    }
    button:hover {
      filter: brightness(1.1); /* General hover effect */
    }
    button:disabled {
        background-color: #6272a4 !important; /* Use important to override specifics */
        cursor: not-allowed;
        opacity: 0.6;
    }

    /* Specific Button Colors */
    .danger { background-color: #ff5555; }
    .primary { background-color: #8be9fd; }
    .secondary { background-color: #bd93f9; }

    /* Style for Toolbar Primary Buttons */
    .toolbar button.primary {
        padding: 5px 8px;   /* Make smaller */
        border-radius: 0;   /* Make square */
        font-size: 0.85rem; /* Slightly smaller font */
    }

    /* Sidebar */
    .sidebar h4 {
        margin: 0 0 10px 0;
        flex-shrink: 0;
        color: #bd93f9; /* Match brand color */
        font-size: 1rem;
    }
    .file-list {
      list-style: none;
      padding: 0;
      margin: 0;
      overflow-y: auto;
      flex-grow: 1;
    }
    .file-item {
      padding: 6px 8px; /* Adjust padding */
      margin-bottom: 3px;
      background-color: #44475a;
      border-radius: 3px; /* Slight rounding */
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem; /* Smaller font for file names */
      transition: background-color 0.15s;
    }
    .file-item:hover { background-color: #50536b; }
    .file-item.active { background-color: #6272a4; font-weight: bold; }
    .file-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-right: 5px;
    }
    .file-name .unsaved-indicator { color: #ffb86c; margin-left: 2px; }
    .file-remove {
      background: none; border: none; color: #ff5555; cursor: pointer;
      font-size: 1rem; line-height: 1; padding: 0 2px; margin-left: auto;
      flex-shrink: 0; opacity: 0.7; transition: opacity 0.15s, color 0.15s;
    }
    .file-remove:hover { color: #ff7777; opacity: 1; }

    /* Editor */
    .CodeMirror {
      height: 100%;
      font-size: 14px;
    }
    /* Ensure scrollbars match theme */
    .cm-s-dracula .CodeMirror-scrollbar-filler, .cm-s-dracula .CodeMirror-gutter-filler { background-color: #282a36; }
    .cm-s-dracula .CodeMirror-vscrollbar::-webkit-scrollbar-thumb { background-color: #44475a; }
    .cm-s-dracula .CodeMirror-vscrollbar::-webkit-scrollbar-thumb:hover { background-color: #6272a4; }
    /* Add basic scrollbar styling for other themes (may need specific overrides) */
    .CodeMirror-vscrollbar::-webkit-scrollbar { width: 10px; }
    .CodeMirror-vscrollbar::-webkit-scrollbar-track { background: rgba(128,128,128,0.1); }
    .CodeMirror-vscrollbar::-webkit-scrollbar-thumb { background: rgba(128,128,128,0.4); border-radius: 4px;}
    .CodeMirror-vscrollbar::-webkit-scrollbar-thumb:hover { background: rgba(128,128,128,0.6); }

    /* AI Suggestion Style */
    .cm-ai-suggestion {
      color: #888; /* Grey color for suggestion */
      font-style: italic;
    }

    /* Modals */
    .modal {
      display: none; position: fixed; z-index: 10; left: 0; top: 0;
      width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7);
    }
    .modal-content {
      background-color: #44475a; margin: 12% auto; padding: 25px; /* More padding */
      border-radius: 6px; width: 450px; max-width: 90%;
      box-shadow: 0 5px 15px rgba(0,0,0,0.5);
    }
    .modal-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 20px; border-bottom: 1px solid #6272a4; padding-bottom: 15px;
    }
    .modal-header h3 { margin: 0; color: #bd93f9; font-size: 1.3rem;}
    .modal-close {
      color: #aaa; font-size: 30px; font-weight: bold; cursor: pointer;
      line-height: 1; padding: 0 5px; transition: color 0.15s;
    }
    .modal-close:hover, .modal-close:focus { color: #ff5555; text-decoration: none; outline: none; }
    .form-group { margin-bottom: 18px; }
    label { display: block; margin-bottom: 6px; font-weight: bold; font-size: 0.9em; }
    input[type="text"], select {
      box-sizing: border-box; width: 100%; padding: 10px; border-radius: 4px;
      border: 1px solid #6272a4; background-color: #282a36; color: #f8f8f2; font-size: 1em;
    }
    input[type="text"]:focus, select:focus {
      outline: none; border-color: #bd93f9;
      box-shadow: 0 0 0 2px rgba(189, 147, 249, 0.3); /* Subtle focus ring */
    }
    .modal-actions {
      display: flex; justify-content: flex-end; gap: 10px; margin-top: 25px;
      padding-top: 15px; border-top: 1px solid #6272a4;
    }

    /* Status Bar */
    .status-bar {
      background-color: #1e1f29; padding: 4px 15px; font-size: 0.8rem;
      display: flex; justify-content: space-between; align-items: center;
      color: #a0a8b0;
    }
    #cursorPosition { margin-left: 15px; } /* Push cursor pos to the right */
    #statusMessage {
        margin-left: 15px; /* Add some spacing */
        font-style: italic;
        color: #ffb86c; /* Orange color for status */
        flex-grow: 1; /* Allow it to take available space */
        text-align: center; /* Center the message */
    }

    /* Language Select */
    .language-select {
      background-color: #44475a; color: #f8f8f2; border: 1px solid #6272a4;
      border-radius: 4px; padding: 5px 8px; font-size: 0.85rem; margin-left: auto; /* Push to right */
    }
    .language-select:disabled { opacity: 0.6; background-color: #6272a4; }
    .language-select:focus { outline: none; border-color: #bd93f9; }

    /* Find/Replace Bar */
    .find-replace-container {
      display: none; gap: 8px; background-color: #373a49; padding: 8px 15px;
      border-bottom: 1px solid #282a36; align-items: center;
    }
    .find-replace-container input[type="text"] {
      flex: 1; padding: 5px 8px; font-size: 0.9rem; min-width: 120px;
    }
    .search-actions { display: flex; gap: 5px; }
    .search-actions button { padding: 4px 8px; font-size: 0.85rem; }
    #closeFindBtn {
         margin-left: 5px; padding: 2px 6px; font-size: 1rem; line-height: 1;
         background-color: #ff5555; /* Match danger color */
    }

  </style>
</head>
<body>
  <div class="navbar">
    <div class="brand">LLamaEdit</div>
    <div>
      <button id="themeToggle" class="secondary" title="Cycle Theme">Cycle Theme</button>
    </div>
  </div>

  <div class="toolbar">
    <!-- Toolbar buttons ... -->
    <button id="newFileBtn" class="primary" title="New File (Ctrl+N)">New</button>
    <button id="openFileBtn" class="primary" title="Open File (Ctrl+O)">Open</button>
    <button id="saveFileBtn" class="primary" title="Save (Ctrl+S)" disabled>Save</button>
    <button id="saveAsBtn" class="primary" title="Save As (Ctrl+Shift+S)" disabled>Save As</button>
    <button id="findReplaceBtn" class="secondary" title="Find & Replace (Ctrl+F)">Find/Replace</button>
    <select id="languageSelect" class="language-select" title="Select Language" disabled>
      <option value="javascript">JavaScript</option>
      <option value="htmlmixed">HTML</option>
      <option value="css">CSS</option>
      <option value="xml">XML</option>
      <option value="text/plain">Plain Text</option>
    </select>
  </div>

  <div class="find-replace-container" id="findReplaceContainer">
    <!-- Find/Replace elements ... -->
    <input type="text" id="findInput" placeholder="Find...">
    <input type="text" id="replaceInput" placeholder="Replace with...">
    <div class="search-actions">
      <button id="findPrevBtn" class="secondary" title="Find Previous (Shift+Enter)">Prev</button>
      <button id="findNextBtn" class="secondary" title="Find Next (Enter)">Next</button>
      <button id="replaceBtn" class="secondary" title="Replace Current">Replace</button>
      <button id="replaceAllBtn" class="secondary" title="Replace All">Replace All</button>
      <button id="closeFindBtn" class="danger" title="Close (Esc)">&times;</button>
    </div>
  </div>

  <div class="editor-container">
    <div class="sidebar">
      <h4>Files</h4>
      <ul class="file-list" id="fileList"></ul>
    </div>
    <div class="main-content">
      <div id="editor"></div>
    </div>
  </div>

  <div class="status-bar">
    <div id="fileInfo">No file opened</div>
    <div id="statusMessage"></div>
    <div id="cursorPosition">Ln 1, Col 1</div>
  </div>


  <!-- New File Modal -->
  <div id="newFileModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Create New File</h3>
        <span class="modal-close" id="closeNewFileModal" title="Close">&times;</span>
      </div>
      <div class="form-group">
        <label for="newFileName">File Name:</label>
        <input type="text" id="newFileName" placeholder="e.g., script.js, index.html">
      </div>
      <div class="form-group">
        <label for="newFileLanguage">Language:</label>
        <select id="newFileLanguage">
          <option value="javascript">JavaScript (.js)</option>
          <option value="htmlmixed">HTML (.html)</option>
          <option value="css">CSS (.css)</option>
          <option value="xml">XML (.xml)</option>
          <option value="text/plain">Plain Text (.txt)</option>
        </select>
      </div>
      <div class="modal-actions">
        <button id="cancelNewFile" class="secondary">Cancel</button>
        <button id="createNewFile" class="primary">Create</button>
      </div>
    </div>
  </div>


  <!-- Save As Modal -->
  <div id="saveAsModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Save File As</h3>
        <span class="modal-close" id="closeSaveAsModal" title="Close">&times;</span>
      </div>
      <div class="form-group">
        <label for="saveAsFileName">File Name:</label>
        <input type="text" id="saveAsFileName" placeholder="example.js">
      </div>
      <div class="modal-actions">
        <button id="cancelSaveAs" class="secondary">Cancel</button>
        <button id="confirmSaveAs" class="primary">Save</button>
      </div>
    </div>
  </div>

  <script>
    // --- AI Configuration ---
    const LLAMA_API_URL = 'http://localhost:8080/completion'; // <<< Your Llama.cpp server URL
    const AI_COMPLETION_MAX_TOKENS = 128; // Max tokens to request from AI (Increased for testing)
    const AI_COMPLETION_STOP_TOKENS = []; // ["\n", "\t", ";", "}", ")", "<|EOT|>"]; // Stop tokens temporarily removed for testing
    const AI_PROMPT_MAX_CHARS = 2048; // Limit context sent to AI

    // --- State Variables ---
    let files = [];
    let currentFileIndex = -1;
    let editor;
    let lastSearch = { query: null, cursor: null, findInputEl: null, replaceInputEl: null };
    let isAICompleting = false; // Flag to prevent concurrent AI requests
    let activeSuggestionMarker = null; // To hold the current suggestion marker
    let isInsertingAISuggestion = false; // Flag to track AI insertion state

    // Theme Management
    const themes = [ "dracula", "material", "monokai", "solarized dark", "default", "eclipse", "base16-light", "solarized light" ];
    const themeTypes = { "dracula": "dark", "material": "dark", "monokai": "dark", "solarized dark": "dark", "default": "light", "eclipse": "light", "base16-light": "light", "solarized light": "light" };
    let currentThemeIndex = 0; // Start with Dracula

    // --- DOM Element References ---
    const fileListEl = document.getElementById("fileList");
    const editorContainerEl = document.getElementById("editor");
    const cursorPositionEl = document.getElementById("cursorPosition");
    const fileInfoEl = document.getElementById("fileInfo");
    const languageSelectEl = document.getElementById("languageSelect");
    const saveFileBtn = document.getElementById("saveFileBtn");
    const saveAsBtn = document.getElementById("saveAsBtn");
    const findReplaceContainerEl = document.getElementById("findReplaceContainer");
    const findInputEl = document.getElementById("findInput");
    const replaceInputEl = document.getElementById("replaceInput");
    lastSearch.findInputEl = findInputEl;
    lastSearch.replaceInputEl = replaceInputEl;
    const newFileModal = document.getElementById("newFileModal");
    const saveAsModal = document.getElementById("saveAsModal");
    const newFileNameInput = document.getElementById("newFileName");
    const newFileLangSelect = document.getElementById("newFileLanguage");
    const saveAsFileNameInput = document.getElementById("saveAsFileName");
    const statusMessageEl = document.getElementById("statusMessage");


    // --- Initialization ---
    function initEditor() {
      editor = CodeMirror(editorContainerEl, {
        mode: "javascript",
        theme: themes[currentThemeIndex],
        lineNumbers: true,
        matchBrackets: true,
        autoCloseBrackets: true,
        indentUnit: 2,
        tabSize: 2,
        indentWithTabs: false,
        lineWrapping: false,
        gutters: ["CodeMirror-linenumbers"],
        extraKeys: {
          "Ctrl-Space": "autocomplete",
          "Ctrl-F": "findPersistent",
          "Cmd-F": "findPersistent",
          "Ctrl-H": "replace",
          "Cmd-Option-F": "replace",
          "Esc": function(cm) {
            if (activeSuggestionMarker) {
                clearActiveSuggestion(false); return;
            }
            if (findReplaceContainerEl.style.display !== 'none') {
                 toggleFindReplace(false); return CodeMirror.Pass;
            }
            return CodeMirror.Pass;
          },
          "Alt-\\": function(cm) {
            triggerAICompletion();
          },
          "Tab": function(cm) {
              if (activeSuggestionMarker) {
                  clearActiveSuggestion(true); return;
              }
              return CodeMirror.Pass;
          }
        }
      });

      editor.on("cursorActivity", handleCursorActivity);
      editor.on("change", handleEditorChange);

      applyBodyThemeStyles(themes[currentThemeIndex]);
      updateUIForFileStatus();
    }

    // --- UI Update Functions ---
    function handleCursorActivity() {
        const cursor = editor.getCursor();
        cursorPositionEl.textContent = `Ln ${cursor.line + 1}, Col ${cursor.ch + 1}`;

        if (activeSuggestionMarker) {
            const markerRange = activeSuggestionMarker.find();
            if (markerRange) {
                const currentCursor = editor.getCursor();
                if (CodeMirror.cmpPos(currentCursor, markerRange.from) < 0 ||
                    CodeMirror.cmpPos(currentCursor, markerRange.to) > 0) {
                     clearActiveSuggestion(false);
                }
            } else {
                 clearActiveSuggestion(false);
            }
        }
    }

    function handleEditorChange(cm, change) {
        // Ignore changes made *while* the AI suggestion is being inserted
        if (isInsertingAISuggestion) {
            console.log("Ignoring change event during AI suggestion insertion.");
            return;
        }

        // Reject suggestion on subsequent user changes
        if (activeSuggestionMarker) {
             console.log("Clearing suggestion due to user change (origin:", change.origin, ")");
             clearActiveSuggestion(false);
        }

        // Unsaved logic
        if (currentFileIndex >= 0 && files[currentFileIndex] && !files[currentFileIndex].unsaved) {
            if (!change.removed || !activeSuggestionMarker) { // Avoid marking unsaved just by rejecting
                 files[currentFileIndex].unsaved = true;
                 updateFileList();
                 updateFileInfo();
                 updateSaveButtonState();
             }
        }
    }

    function updateFileList() {
        fileListEl.innerHTML = "";
        if (files.length === 0) {
            const li = document.createElement("li"); li.textContent = "No files open"; li.style.padding = "8px"; li.style.color = "#a0a8b0"; li.style.fontSize = "0.85rem"; fileListEl.appendChild(li); return;
        }
        files.forEach((file, index) => {
            const li = document.createElement("li"); li.className = `file-item ${index === currentFileIndex ? "active" : ""}`; li.title = file.name; li.dataset.index = index; li.onclick = () => openFileByIndex(index);
            const nameSpan = document.createElement("span"); nameSpan.className = "file-name"; nameSpan.textContent = file.name;
            if (file.unsaved) {
                const unsavedIndicator = document.createElement("span"); unsavedIndicator.className = "unsaved-indicator"; unsavedIndicator.textContent = "*"; unsavedIndicator.title = "Unsaved changes"; nameSpan.appendChild(unsavedIndicator);
            }
            const removeBtn = document.createElement("button"); removeBtn.className = "file-remove"; removeBtn.innerHTML = "&times;"; removeBtn.title = `Close ${file.name}`; removeBtn.dataset.index = index; removeBtn.onclick = (e) => { e.stopPropagation(); removeFile(index); };
            li.appendChild(nameSpan); li.appendChild(removeBtn); fileListEl.appendChild(li);
        });
    }
    function updateFileInfo() {
        if (currentFileIndex >= 0 && files[currentFileIndex]) {
            const file = files[currentFileIndex]; fileInfoEl.textContent = `${file.name}${file.unsaved ? " (unsaved)" : ""}`; languageSelectEl.value = file.language;
        } else {
            fileInfoEl.textContent = "No file opened"; languageSelectEl.value = "text/plain"; cursorPositionEl.textContent = `Ln 1, Col 1`;
        }
    }
    function updateSaveButtonState() {
        const canSave = currentFileIndex >= 0 && files[currentFileIndex] && files[currentFileIndex].unsaved; saveFileBtn.disabled = !canSave; saveAsBtn.disabled = !(currentFileIndex >= 0 && files[currentFileIndex]);
    }
    function updateLanguageDropdownState() {
        languageSelectEl.disabled = !(currentFileIndex >= 0 && files[currentFileIndex]);
    }
    function updateUIForFileStatus() {
        updateFileList(); updateFileInfo(); updateSaveButtonState(); updateLanguageDropdownState();
    }
    function setStatusMessage(message = "", isError = false) {
        statusMessageEl.textContent = message; statusMessageEl.style.color = isError ? "#ff5555" : "#ffb86c";
    }


    // --- File Management Logic ---
    // <<< MODIFICATION: Fixed setActiveFile >>>
    function setActiveFile(index) {
        console.log(`setActiveFile called with index: ${index}`);
        clearActiveSuggestion(false); // Clear suggestion when switching files

        if (index < 0 || index >= files.length) {
            currentFileIndex = -1;
            editor.setValue(""); editor.clearHistory();
            editor.setOption("mode", "text/plain"); updateUIForFileStatus(); return;
        }
        if (index === currentFileIndex) return; // Already active
        currentFileIndex = index; const file = files[currentFileIndex];
        // Use operation to ensure setValue and mode change are atomic if needed
        editor.operation(() => {
            editor.setValue(file.content);
            editor.setOption("mode", file.language);
        });
        editor.clearHistory(); // Clear history after setting content
        editor.focus();
        updateUIForFileStatus(); // Update UI after everything is set
    }

    function openFileByIndex(index) { setActiveFile(index); }
    function createNewFile(name, language) {
        if (!name) { alert("File name cannot be empty."); return false; } if (files.some(f => f.name === name)) { alert(`A file named "${name}" already exists.`); return false; }
        const newFile = { name: name, content: "", language: language, unsaved: true, handle: null }; files.push(newFile);
        // <<< Clear suggestion before activating new file >>>
        clearActiveSuggestion(false);
        setActiveFile(files.length - 1); return true;
    }
    function removeFile(index) {
        if (index < 0 || index >= files.length) return; const fileToRemove = files[index]; if (fileToRemove.unsaved) { if (!confirm(`Discard unsaved changes in "${fileToRemove.name}"?`)) return; }
        files.splice(index, 1); let nextIndex = -1; if (files.length === 0) nextIndex = -1; else if (currentFileIndex === index) nextIndex = Math.max(0, index - 1); else if (currentFileIndex > index) nextIndex = currentFileIndex - 1; else nextIndex = currentFileIndex;
        // <<< Clear suggestion before activating next file >>>
        clearActiveSuggestion(false);
        setActiveFile(nextIndex);
    }


    // --- File Saving/Loading ---
    function getMimeType(language) { switch (language) { case "javascript": return "text/javascript"; case "htmlmixed": return "text/html"; case "css": return "text/css"; case "xml": return "text/xml"; default: return "text/plain"; } }
    function getSuggestedExtension(language) { switch (language) { case "javascript": return ".js"; case "htmlmixed": return ".html"; case "css": return ".css"; case "xml": return ".xml"; default: return ".txt"; } }
    function getLanguageFromFileName(name) { const extension = name.split('.').pop().toLowerCase(); switch (extension) { case "js": return "javascript"; case "html": case "htm": return "htmlmixed"; case "css": return "css"; case "xml": case "svg": return "xml"; case "json": return "javascript"; case "md": return "text/plain"; default: return "text/plain"; } }
    function getFilePickerTypes() { return [ { description: 'JavaScript', accept: { 'text/javascript': ['.js'] } }, { description: 'HTML', accept: { 'text/html': ['.html', '.htm'] } }, { description: 'CSS', accept: { 'text/css': ['.css'] } }, { description: 'XML', accept: { 'text/xml': ['.xml', '.svg'] } }, { description: 'Text Files', accept: { 'text/plain': ['.txt'] } }, { description: 'All Files', accept: {'*/*': []} } ]; }
    async function saveFile(isSaveAs = false) {
        clearActiveSuggestion(false); // Clear suggestion before saving
        if (currentFileIndex < 0 || !files[currentFileIndex]) { console.error("Save attempt failed: No active file."); return; }
        const file = files[currentFileIndex]; file.content = editor.getValue(); let handle = file.handle;
        const suggestedName = isSaveAs ? saveAsFileNameInput.value.trim() : file.name; if (!suggestedName) { alert("Please enter a file name."); if(isSaveAs) saveAsFileNameInput.focus(); return; }
        if (window.showSaveFilePicker) {
            try {
                if (isSaveAs || !handle) {
                    handle = await window.showSaveFilePicker({ suggestedName: suggestedName, types: getFilePickerTypes() }); file.handle = handle;
                    if (isSaveAs || file.name !== handle.name) { file.name = handle.name; const newLang = getLanguageFromFileName(file.name); if (newLang !== file.language) { file.language = newLang; editor.setOption("mode", newLang); } }
                }
                const writable = await handle.createWritable(); await writable.write(file.content); await writable.close();
                file.unsaved = false; console.log(`File "${handle.name}" saved via FSA API.`); setStatusMessage(`Saved ${handle.name}`); updateUIForFileStatus();
            } catch (err) {
                if (err.name === 'AbortError') { console.log("Save cancelled."); setStatusMessage("Save cancelled"); return; }
                console.error("Error saving with FSA API:", err); setStatusMessage(`Save failed: ${err.message}`, true);
                if (!isSaveAs) { console.log("Falling back to download method."); setStatusMessage("FSA API failed, falling back to download...", true); triggerDownload(file.name, file.content, file.language); file.unsaved = false; updateUIForFileStatus(); }
            }
        } else {
            console.log("FSA API not supported. Using download."); if (isSaveAs) { file.name = suggestedName; file.language = getLanguageFromFileName(suggestedName); editor.setOption("mode", file.language); }
            triggerDownload(file.name, file.content, file.language); file.unsaved = false; setStatusMessage(`Downloaded ${file.name}`); updateUIForFileStatus();
        }
    }
    function triggerDownload(filename, content, language) { const blob = new Blob([content], { type: getMimeType(language) }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); console.log(`Download initiated: "${filename}".`); }
    function handleSaveClick() { saveFile(false); }
    function handleSaveAsConfirm() { saveFile(true); closeModal(saveAsModal); }

    // <<< MODIFICATION: Fixed openFile function >>>
    async function openFile() {
        console.log("openFile started"); // Keep for debugging

        if (window.showOpenFilePicker) {
            console.log("Using showOpenFilePicker");
            try {
                // Clear suggestion *before* showing the picker
                clearActiveSuggestion(false);

                const [handle] = await window.showOpenFilePicker({ types: getFilePickerTypes(), multiple: false });
                console.log("File handle obtained:", handle.name);

                // Check if already open via handle
                const existingIndex = files.findIndex(f => f.handle && f.handle.isSameEntry && f.handle.isSameEntry(handle));
                if (existingIndex !== -1) {
                    console.log(`Switching to already open file: "${handle.name}"`);
                    setStatusMessage(`Switched to ${handle.name}`);
                    // setActiveFile already clears suggestions if needed
                    setActiveFile(existingIndex);
                    return;
                }
                // Check if already open by name (fallback)
                const existingNameIndex = files.findIndex(f => f.name === handle.name);
                 if (existingNameIndex !== -1) {
                    if (confirm(`"${handle.name}" is already open (without a file handle). Reload it? (Unsaved changes will be lost)`)) {
                        const fileData = await handle.getFile(); const content = await fileData.text();
                        files[existingNameIndex].content = content; files[existingNameIndex].unsaved = false;
                        files[existingNameIndex].handle = handle;
                        files[existingNameIndex].language = getLanguageFromFileName(fileData.name); // Update language too
                        // Clear suggestion right before activating/updating
                        clearActiveSuggestion(false);
                        if (currentFileIndex === existingNameIndex) setActiveFile(existingNameIndex);
                        else updateFileList();
                        console.log(`Reloaded "${handle.name}" from disk.`);
                        setStatusMessage(`Reloaded ${handle.name}`);
                        return;
                    } else {
                        console.log(`Did not reload "${handle.name}". Keeping existing tab.`);
                         // Clear suggestion right before activating
                        clearActiveSuggestion(false);
                        setActiveFile(existingNameIndex);
                        return;
                    }
                }
                // Open as new file
                const fileData = await handle.getFile(); const content = await fileData.text();
                const language = getLanguageFromFileName(fileData.name);
                const newFile = { name: fileData.name, content: content, language: language, unsaved: false, handle: handle };
                files.push(newFile);
                // Clear suggestion right before activating
                clearActiveSuggestion(false);
                setActiveFile(files.length - 1);
                console.log(`Opened "${handle.name}" via FSA API.`);
                setStatusMessage(`Opened ${handle.name}`);
            } catch (err) {
                console.error("Error within showOpenFilePicker try block:", err);
                if (err.name === 'AbortError') { console.log("Open cancelled by user."); setStatusMessage("Open cancelled"); }
                else { console.error("Error opening with FSA API:", err); setStatusMessage(`Open failed: ${err.message}`, true); }
            }
        } else {
            console.log("FSA API not supported. Using <input type='file'>.");
            triggerLegacyFileOpen(); // Call the legacy method
        }
         console.log("openFile finished"); // Keep for debugging
    }

    // <<< MODIFICATION: Fixed triggerLegacyFileOpen function >>>
    function triggerLegacyFileOpen() {
        console.log("triggerLegacyFileOpen started");
        // Clear suggestion right before creating the input
        clearActiveSuggestion(false);

        const input = document.createElement("input"); input.type = "file";
        const acceptString = getFilePickerTypes().flatMap(type => Object.values(type.accept).flat()).filter(ext => ext).join(',') || ".txt,.js,.html,.css,.xml";
        input.accept = acceptString;

        input.onchange = function(e) {
          if (e.target.files && e.target.files.length > 0) {
            const file = e.target.files[0];
            console.log("Legacy input changed, file selected:", file.name);

            const existingIndex = files.findIndex(f => f.name === file.name);
            if (existingIndex !== -1) {
                 if (confirm(`"${file.name}" is already open. Reload it? (Unsaved changes will be lost)`)) {
                     const reader = new FileReader();
                     reader.onload = (ev) => {
                         files[existingIndex].content = ev.target.result; files[existingIndex].unsaved = false;
                         files[existingIndex].language = getLanguageFromFileName(file.name);
                         // Clear suggestion right before activating/updating
                         clearActiveSuggestion(false);
                         if (currentFileIndex === existingIndex) setActiveFile(existingIndex);
                         else updateFileList();
                         console.log(`Reloaded "${file.name}" (legacy).`); setStatusMessage(`Reloaded ${file.name}`);
                     }; reader.readAsText(file);
                 } else {
                     console.log(`Did not reload "${file.name}".`); setStatusMessage(`Kept existing ${file.name}`);
                     // Clear suggestion right before activating
                     clearActiveSuggestion(false);
                     setActiveFile(existingIndex);
                 } return;
            }
            // Open as new file (legacy)
            const reader = new FileReader();
            reader.onload = function(ev) {
              const content = ev.target.result; const language = getLanguageFromFileName(file.name);
              const newFile = { name: file.name, content: content, language: language, unsaved: false, handle: null };
              files.push(newFile);
              // Clear suggestion right before activating
              clearActiveSuggestion(false);
              setActiveFile(files.length - 1);
              console.log(`Opened "${file.name}" (legacy).`); setStatusMessage(`Opened ${file.name}`);
            }; reader.onerror = (err) => { console.error("FileReader error:", err); setStatusMessage(`Error reading ${file.name}`, true); alert(`Error reading file: ${file.name}`); }
            reader.readAsText(file);
          } else {
              console.log("Legacy input change event fired, but no file selected.");
          }
        };
        input.click(); // Trigger the input click
        console.log("Legacy input clicked.");
    }


    // --- Find & Replace Logic ---
    function toggleFindReplace(show) {
        clearActiveSuggestion(false); // Clear suggestion when opening find/replace
        findReplaceContainerEl.style.display = show ? "flex" : "none";
        if (show) { const selection = editor.getSelection(); if (selection) findInputEl.value = selection; findInputEl.focus(); findInputEl.select(); lastSearch.cursor = null; lastSearch.query = null; }
        else { editor.focus(); }
    }
    function find(reverse = false) { if (!editor) return; const query = findInputEl.value; if (!query) { setStatusMessage("Find: No query", true); return; } const caseSensitive = false; setStatusMessage(`Finding "${query}"...`); const searchCursor = editor.getSearchCursor(query, reverse ? editor.getCursor("from") : editor.getCursor("to"), { caseFold: !caseSensitive, reverse: reverse }); if (!searchCursor.find(reverse)) { const startPos = reverse ? CodeMirror.Pos(editor.lastLine()) : CodeMirror.Pos(0, 0); const wrapCursor = editor.getSearchCursor(query, startPos, { caseFold: !caseSensitive, reverse: reverse }); if (!wrapCursor.find(reverse)) { setStatusMessage(`"${query}" not found`); return; } editor.setSelection(wrapCursor.from(), wrapCursor.to()); setStatusMessage(`Found "${query}" (wrapped)`); } else { editor.setSelection(searchCursor.from(), searchCursor.to()); setStatusMessage(`Found "${query}"`); } editor.scrollIntoView({ from: editor.getCursor("from"), to: editor.getCursor("to") }, 50); }
    function replace() { if (!editor) return; const query = findInputEl.value; const replacement = replaceInputEl.value; const selection = editor.getSelection(); const caseSensitive = false; const selectionMatches = selection && (caseSensitive ? selection === query : selection.toLowerCase() === query.toLowerCase()); if (selection && selectionMatches) { editor.replaceSelection(replacement, "around"); setStatusMessage(`Replaced "${query}"`); find(false); } else { find(false); } }
    function replaceAll() { if (!editor) return; const query = findInputEl.value; const replacement = replaceInputEl.value; if (!query) { setStatusMessage("Replace All: No query", true); return; } const caseSensitive = false; let count = 0; editor.operation(() => { const cursor = editor.getSearchCursor(query, CodeMirror.Pos(0, 0), { caseFold: !caseSensitive }); while (cursor.findNext()) { cursor.replace(replacement); count++; } }); setStatusMessage(`Replaced ${count} instance(s) of "${query}"`); }


    // --- Theme Management ---
    function applyBodyThemeStyles(themeName) { const type = themeTypes[themeName] || 'dark'; if (type === 'light') { document.body.style.backgroundColor = "#ffffff"; document.body.style.color = "#333333"; } else { document.body.style.backgroundColor = "#282a36"; document.body.style.color = "#f8f8f2"; } }
    function cycleTheme() { currentThemeIndex = (currentThemeIndex + 1) % themes.length; const newTheme = themes[currentThemeIndex]; editor.setOption("theme", newTheme); applyBodyThemeStyles(newTheme); console.log(`Theme: ${newTheme}`); document.getElementById('themeToggle').title = `Current Theme: ${newTheme}`; setStatusMessage(`Theme set to ${newTheme}`); }


    // --- Modal Handling ---
    function openModal(modalElement) {
        clearActiveSuggestion(false); // Clear suggestion when opening modal
        modalElement.style.display = "block"; const firstInput = modalElement.querySelector('input[type="text"], select'); if (firstInput) { setTimeout(() => firstInput.focus(), 50); if (firstInput.select) firstInput.select(); }
    }
    function closeModal(modalElement) { modalElement.style.display = "none"; editor.focus(); }
    window.addEventListener('click', (event) => { if (event.target.classList.contains('modal')) closeModal(event.target); });


    // --- AI Suggestion Management ---
    function clearActiveSuggestion(accepted = false) {
        if (activeSuggestionMarker) {
            const marker = activeSuggestionMarker; const markerId = marker.id; activeSuggestionMarker = null;
            console.log(`Clearing suggestion marker ${markerId}. Accepted: ${accepted}`);
            if (accepted) {
                marker.clear(); const range = marker.find(); if (range) { editor.setCursor(range.to); } setStatusMessage("Suggestion accepted");
            } else {
                const range = marker.find();
                if (range) { editor.operation(() => { editor.replaceRange("", range.from, range.to); }); console.log(`Suggestion marker ${markerId} rejected and removed.`); setStatusMessage("Suggestion dismissed");
                } else { marker.clear(); console.log(`Suggestion marker ${markerId} rejected (marker cleared, range not found).`); setStatusMessage("Suggestion dismissed"); }
            }
             setTimeout(() => { if (statusMessageEl.textContent === "Suggestion accepted" || statusMessageEl.textContent === "Suggestion dismissed") { setStatusMessage(""); } }, 2000);
        }
    }

    // --- AI Completion ---
    async function triggerAICompletion() {
        if (!editor || isAICompleting || currentFileIndex < 0) { if (isAICompleting) setStatusMessage("AI is already working...", true); else setStatusMessage("AI Completion not available", true); return; }
        clearActiveSuggestion(false); isAICompleting = true; setStatusMessage("AI thinking...");
        try {
            const cursor = editor.getCursor(); const textBeforeCursor = editor.getRange(CodeMirror.Pos(0, 0), cursor); const promptText = textBeforeCursor.slice(-AI_PROMPT_MAX_CHARS);
            console.log("--- Sending Prompt to AI ---"); console.log(promptText);
            const completion = await fetchAICompletion(promptText);
            console.log("--- Raw Completion Received ---"); console.log(JSON.stringify(completion));
            if (completion && completion.trim() !== "") {
                const from = cursor; isInsertingAISuggestion = true; let marker;
                editor.operation(() => {
                    editor.replaceRange(completion, from, from, "+AICompletion"); const to = editor.getCursor(); marker = editor.markText(from, to, { className: 'cm-ai-suggestion' }); activeSuggestionMarker = marker;
                    marker.on('clear', () => { if (activeSuggestionMarker && activeSuggestionMarker.id === marker.id) { console.log(`Suggestion marker ${marker.id} cleared externally or by accept/reject.`); activeSuggestionMarker = null; } });
                });
                setStatusMessage("AI Suggestion: Tab=Accept, Esc=Dismiss"); console.log("AI Suggestion displayed:", completion);
            } else { console.warn("Completion was empty or null after processing."); setStatusMessage("AI returned no useful completion"); }
        } catch (error) { console.error("AI Completion Error:", error); setStatusMessage(`AI Error: ${error.message}`, true); clearActiveSuggestion(false);
        } finally { isAICompleting = false; isInsertingAISuggestion = false; if (statusMessageEl.textContent === "AI thinking...") { setStatusMessage(""); } }
    }

    async function fetchAICompletion(prompt) {
        try {
             const requestBody = { prompt: prompt, n_predict: AI_COMPLETION_MAX_TOKENS, temperature: 0.7, stop: AI_COMPLETION_STOP_TOKENS };
             console.log("--- Sending Request Body ---"); console.log(JSON.stringify(requestBody, null, 2));
             const response = await fetch(LLAMA_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify(requestBody) });
             if (!response.ok) { throw new Error(`API request failed: ${response.status} ${response.statusText} - ${await response.text()}`); }
             const data = await response.json();
             console.log("--- Raw Response Data from Server ---"); console.log(JSON.stringify(data, null, 2));
             if (data && data.content) { return data.content.replace(/^\s+/, ""); }
             else { console.warn("AI response format unexpected or 'content' field missing/empty in raw data:", data); return null; }
        } catch (error) { console.error("Fetch AI Completion failed:", error); throw new Error(`Could not reach AI server or parse response: ${error.message}`); }
    }


    // --- Event Listener Setup ---
    function setupEventListeners() {
      // Toolbar Buttons
      document.getElementById("newFileBtn").addEventListener("click", () => { newFileNameInput.value = ""; openModal(newFileModal); });
      document.getElementById("openFileBtn").addEventListener("click", openFile); // Event listener points to the fixed function
      saveFileBtn.addEventListener("click", handleSaveClick);
      saveAsBtn.addEventListener("click", () => { if (currentFileIndex >= 0 && files[currentFileIndex]) saveAsFileNameInput.value = files[currentFileIndex].name; else saveAsFileNameInput.value = ""; openModal(saveAsModal); });
      document.getElementById("findReplaceBtn").addEventListener("click", () => toggleFindReplace(true));
      document.getElementById("themeToggle").addEventListener("click", cycleTheme);
      document.getElementById('themeToggle').title = `Current Theme: ${themes[currentThemeIndex]}`;

      // Language Select Change
      languageSelectEl.addEventListener("change", function() { if (currentFileIndex >= 0 && files[currentFileIndex]) { clearActiveSuggestion(false); const newLang = this.value; files[currentFileIndex].language = newLang; editor.setOption("mode", newLang); setStatusMessage(`Language set to ${this.options[this.selectedIndex].text}`); files[currentFileIndex].unsaved = true; updateUIForFileStatus(); } });

      // Find/Replace Buttons & Inputs
      document.getElementById("findPrevBtn").addEventListener("click", () => find(true)); document.getElementById("findNextBtn").addEventListener("click", () => find(false)); document.getElementById("replaceBtn").addEventListener("click", replace); document.getElementById("replaceAllBtn").addEventListener("click", replaceAll); document.getElementById("closeFindBtn").addEventListener("click", () => toggleFindReplace(false));
      findInputEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); find(e.shiftKey); } else if (e.key === 'Escape') { toggleFindReplace(false); } });
      replaceInputEl.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); replace(); } else if (e.key === 'Escape') { toggleFindReplace(false); } });

      // Modal Buttons & Inputs
      document.getElementById("closeNewFileModal").addEventListener("click", () => closeModal(newFileModal)); document.getElementById("cancelNewFile").addEventListener("click", () => closeModal(newFileModal)); document.getElementById("createNewFile").addEventListener("click", () => { if (createNewFile(newFileNameInput.value.trim(), newFileLangSelect.value)) closeModal(newFileModal); else newFileNameInput.focus(); });
      document.getElementById("closeSaveAsModal").addEventListener("click", () => closeModal(saveAsModal)); document.getElementById("cancelSaveAs").addEventListener("click", () => closeModal(saveAsModal)); document.getElementById("confirmSaveAs").addEventListener("click", handleSaveAsConfirm);
      newFileNameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') document.getElementById('createNewFile').click(); }); newFileLangSelect.addEventListener('keydown', (e) => { if (e.key === 'Enter') document.getElementById('createNewFile').click(); }); saveAsFileNameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') document.getElementById('confirmSaveAs').click(); });

      // Global Keyboard Shortcuts
      document.addEventListener("keydown", function(e) {
        const modKey = e.metaKey || e.ctrlKey; const activeEl = document.activeElement; const isInputFocused = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'SELECT' || activeEl.tagName === 'TEXTAREA'); const isModalOpen = newFileModal.style.display === 'block' || saveAsModal.style.display === 'block'; const isFindReplaceOpen = findReplaceContainerEl.style.display === 'flex';
        if (editor.hasFocus() && !(isInputFocused && (isModalOpen || isFindReplaceOpen))) { return; } // Let CM handle editor keys
        if (isInputFocused && (isModalOpen || isFindReplaceOpen)) { if (e.key === 'Escape') { if (isFindReplaceOpen && (activeEl === findInputEl || activeEl === replaceInputEl)) { toggleFindReplace(false); } } return; } // Let inputs handle keys (except Esc in find)
        if (modKey && (e.key === "s" || e.key === "S")) { e.preventDefault(); if (e.shiftKey) { if (!saveAsBtn.disabled) { if (currentFileIndex >= 0 && files[currentFileIndex]) saveAsFileNameInput.value = files[currentFileIndex].name; else saveAsFileNameInput.value = ""; openModal(saveAsModal); } } else { if (!saveFileBtn.disabled) handleSaveClick(); } }
        else if (modKey && (e.key === "o" || e.key === "O")) { e.preventDefault(); openFile(); }
        else if (modKey && (e.key === "n" || e.key === "N")) { e.preventDefault(); newFileNameInput.value = ""; openModal(newFileModal); }
        else if (e.key === 'Escape') { if (newFileModal.style.display === 'block') { e.preventDefault(); closeModal(newFileModal); } else if (saveAsModal.style.display === 'block') { e.preventDefault(); closeModal(saveAsModal); } }
      });

      // Warn before leaving page
      window.addEventListener('beforeunload', (event) => { const hasUnsaved = files.some(file => file.unsaved); if (hasUnsaved) { const msg = 'You have unsaved changes. Are you sure you want to leave?'; event.preventDefault(); event.returnValue = msg; return msg; } });
    }


    // --- App Entry Point ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Loaded, initializing editor...");
        initEditor();
        setupEventListeners();
        if (currentFileIndex === -1) updateUIForFileStatus();
        setStatusMessage("Editor ready (Alt+\\ for AI)");
    });

  </script>
</body>
</html>
