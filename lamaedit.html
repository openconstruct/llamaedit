<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LLamaEdit</title>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/dialog/dialog.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/search/search.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/search/searchcursor.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/dialog/dialog.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/matchbrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/edit/closebrackets.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/show-hint.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/hint/javascript-hint.min.js"></script> 

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/lint/lint.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/lint/lint.min.js"></script>

<script src="https://unpkg.com/jshint@2.13.6/dist/jshint.js"></script> 
<script src="https://unpkg.com/jsonlint@1.6.3/web/jsonlint.js"></script> 
<script src="https://unpkg.com/csslint@1.0.5/dist/csslint.js"></script> 
<script src="https://unpkg.com/htmlhint@1.1.4/dist/htmlhint.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script> 

<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/lint/javascript-lint.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/lint/json-lint.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/lint/css-lint.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/lint/html-lint.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/addon/lint/yaml-lint.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/xml/xml.min.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/javascript/javascript.min.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/css/css.min.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/htmlmixed/htmlmixed.min.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/clike/clike.min.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/go/go.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/lua/lua.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/markdown/markdown.min.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/perl/perl.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/php/php.min.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/python/python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/r/r.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/ruby/ruby.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/rust/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/shell/shell.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/sql/sql.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/swift/swift.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/yaml/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/javascript/javascript.min.js"></script> 
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/typescript/typescript.min.js"></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/dracula.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/material.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/monokai.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/eclipse.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/base16-light.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/solarized.min.css">
<style>
/* --- STYLES (unchanged from original) --- */
:root {
    /* ... (color variables remain the same) ... */
    --app-bg-light: #ececec; /* System-like light background */
    --app-fg-light: #1e1e1e;
    --menu-bg-light: #f0f0f0;
    --toolbar-bg-light: #f5f5f5;
    --sidebar-bg-light: #f8f8f8;
    --statusbar-bg-light: #e0e0e0;
    --border-color-light: #cccccc;
    --button-bg-light: #e1e1e1;
    --button-hover-bg-light: #d1d1d1;
    --button-active-bg-light: #c1c1c1;
    --button-fg-light: #222222;
    --modal-bg-light: #ffffff;
    --modal-header-bg-light: #f0f0f0;
    --input-bg-light: #ffffff;
    --input-border-light: #aaaaaa;
    --input-focus-border-light: #0078d4;

    --app-bg-dark: #2d2d2d; /* System-like dark background */
    --app-fg-dark: #f1f1f1;
    --menu-bg-dark: #383838;
    --toolbar-bg-dark: #3c3c3c;
    --sidebar-bg-dark: #333333;
    --statusbar-bg-dark: #252525;
    --border-color-dark: #444444;
    --button-bg-dark: #555555;
    --button-hover-bg-dark: #666666;
    --button-active-bg-dark: #777777;
    --button-fg-dark: #e0e0e0;
    --modal-bg-dark: #424242;
    --modal-header-bg-dark: #3a3a3a;
    --input-bg-dark: #303030;
    --input-border-dark: #555555;
    --input-focus-border-dark: #0078d4;

    --app-bg: var(--app-bg-dark);
    --app-fg: var(--app-fg-dark);
    --menu-bg: var(--menu-bg-dark);
    --toolbar-bg: var(--toolbar-bg-dark);
    --sidebar-bg: var(--sidebar-bg-dark);
    --statusbar-bg: var(--statusbar-bg-dark);
    --border-color: var(--border-color-dark);
    --button-bg: var(--button-bg-dark);
    --button-hover-bg: var(--button-hover-bg-dark);
    --button-active-bg: var(--button-active-bg-dark);
    --button-fg: var(--button-fg-dark);
    --modal-bg: var(--modal-bg-dark);
    --modal-header-bg: var(--modal-header-bg-dark);
    --input-bg: var(--input-bg-dark);
    --input-border: var(--input-border-dark);
    --input-focus-border: var(--input-focus-border-dark);

    --primary-color: #8be9fd;
    --secondary-color: #bd93f9;
    --danger-color: #ff5555;
    --success-color: #50fa7b;
    --warning-color: #ffb86c;
    --info-color: #8be9fd;
}
body.theme-light {
    --app-bg: var(--app-bg-light);
    --app-fg: var(--app-fg-light);
    --menu-bg: var(--menu-bg-light);
    --toolbar-bg: var(--toolbar-bg-light);
    --sidebar-bg: var(--sidebar-bg-light);
    --statusbar-bg: var(--statusbar-bg-light);
    --border-color: var(--border-color-light);
    --button-bg: var(--button-bg-light);
    --button-hover-bg: var(--button-hover-bg-light);
    --button-active-bg: var(--button-active-bg-light);
    --button-fg: var(--button-fg-light);
    --modal-bg: var(--modal-bg-light);
    --modal-header-bg: var(--modal-header-bg-light);
    --input-bg: var(--input-bg-light);
    --input-border: var(--input-border-light);
    --input-focus-border: var(--input-focus-border-light);
}
html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: var(--app-bg); color: var(--app-fg); transition: background-color 0.2s, color 0.2s; display: flex; flex-direction: column; }
.app-container { display: flex; flex-direction: column; height: 100%; box-sizing: border-box; overflow: hidden; }
.menu-bar { background-color: var(--menu-bg); padding: 0 5px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; height: 30px; display: flex; align-items: center; user-select: none; z-index: 10; }
ul.menu { list-style: none; padding: 0; margin: 0; display: flex; height: 100%; }
li.menu-item { position: relative; padding: 0 10px; cursor: default; display: flex; align-items: center; height: 100%; font-size: 0.85rem; transition: background-color 0.1s; }
li.menu-item:hover { background-color: var(--button-hover-bg); }
ul.submenu { display: none; position: absolute; top: 100%; left: 0; background-color: var(--menu-bg); border: 1px solid var(--border-color); border-top: none; list-style: none; padding: 5px 0; margin: 0; min-width: 180px; z-index: 100; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); }
li.menu-item:hover > ul.submenu { display: block; }
li.submenu-item { padding: 6px 15px; font-size: 0.85rem; cursor: pointer; white-space: nowrap; transition: background-color 0.1s; display: flex; justify-content: space-between; align-items: center; }
li.submenu-item:hover { background-color: var(--button-hover-bg); }
li.submenu-item.disabled { color: #888; cursor: not-allowed; background-color: transparent !important; }
li.submenu-item kbd { font-size: 0.8em; color: #777; padding-left: 15px; }
body.theme-light li.submenu-item kbd { color: #555; }
body.theme-light li.submenu-item.disabled { color: #aaa; }
.menu-separator { height: 1px; background-color: var(--border-color); margin: 5px 0; }
li.menu-item > ul.submenu > li.menu-item { position: relative; }
li.menu-item > ul.submenu > li.menu-item > ul.submenu { top: -6px; left: 100%; border-top: 1px solid var(--border-color); }
.toolbar { display: flex; gap: 5px; background-color: var(--toolbar-bg); padding: 5px 8px; border-bottom: 1px solid var(--border-color); align-items: center; flex-shrink: 0; }
.find-replace-container { display: none; gap: 8px; background-color: var(--toolbar-bg); padding: 5px 8px; border-bottom: 1px solid var(--border-color); align-items: center; flex-shrink: 0; }
.editor-container { flex: 1; display: flex; min-height: 0; overflow: hidden; }
.sidebar { width: 220px; background-color: var(--sidebar-bg); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; flex-shrink: 0; overflow: hidden; }
.sidebar h4 { margin: 0; padding: 8px 10px; font-size: 0.9rem; font-weight: 600; color: var(--app-fg); flex-shrink: 0; border-bottom: 1px solid var(--border-color); }
.file-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
.file-item { padding: 5px 10px; display: flex; justify-content: space-between; align-items: center; font-size: 0.85rem; cursor: pointer; transition: background-color 0.1s; white-space: nowrap; border-bottom: 1px solid transparent; }
.file-item:hover { background-color: var(--button-hover-bg); }
.file-item.active { background-color: var(--input-focus-border); color: white; font-weight: 500; }
body.theme-light .file-item.active { color: white; }
.file-name { overflow: hidden; text-overflow: ellipsis; margin-right: 5px; flex-grow: 1; }
.file-name .unsaved-indicator { color: var(--warning-color); margin-left: 2px; font-weight: bold; }
.file-remove { background: none; border: none; color: var(--danger-color); cursor: pointer; font-size: 1rem; line-height: 1; padding: 0 4px; margin-left: auto; flex-shrink: 0; opacity: 0.6; transition: opacity 0.15s, color 0.15s; }
.file-item:hover .file-remove { opacity: 1; }
.file-item.active .file-remove { color: white; }
.file-remove:hover { color: #ff7777; opacity: 1; }
.main-content { flex: 1; display: flex; flex-direction: column; min-width: 0; position: relative; overflow: hidden; }
#editor { }
.CodeMirror { position: absolute; top: 0; left: 0; right: 0; bottom: 0; height: 100% !important; font-size: 14px; border: none; }
.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler { background-color: transparent; }
.CodeMirror-vscrollbar::-webkit-scrollbar { width: 12px; }
.CodeMirror-vscrollbar::-webkit-scrollbar-track { background: var(--sidebar-bg); }
.CodeMirror-vscrollbar::-webkit-scrollbar-thumb { background: rgba(128,128,128,0.4); border: 3px solid transparent; background-clip: content-box; border-radius: 6px;}
.CodeMirror-vscrollbar::-webkit-scrollbar-thumb:hover { background: rgba(128,128,128,0.6); }
.cm-s-dracula.CodeMirror { background-color: #282a36; }
.cm-s-dracula .CodeMirror-scrollbar-filler, .cm-s-dracula .CodeMirror-gutter-filler { background-color: #282a36; }
.cm-s-dracula .CodeMirror-vscrollbar::-webkit-scrollbar-track { background: #333338; }
.cm-s-dracula .CodeMirror-vscrollbar::-webkit-scrollbar-thumb { background-color: #44475a; }
.cm-s-dracula .CodeMirror-vscrollbar::-webkit-scrollbar-thumb:hover { background-color: #6272a4; }
.status-bar { background-color: var(--statusbar-bg); padding: 0 5px; font-size: 0.75rem; display: flex; justify-content: space-between; align-items: stretch; color: var(--app-fg); border-top: 1px solid var(--border-color); flex-shrink: 0; user-select: none; height: 22px; line-height: 22px; }
#fileInfo, #cursorPosition, #statusMessage, #languageSelectStatus { padding: 0 8px; border-right: 1px solid var(--border-color); white-space: nowrap; display: flex; align-items: center; }
#fileInfo { border-left: 1px solid var(--border-color); }
#statusMessage { flex-grow: 1; text-align: left; border-right: none; overflow: hidden; text-overflow: ellipsis; }
#cursorPosition { border-right: none; }
#languageSelectStatus { border-right: none; margin-left: 5px; }
#languageSelectStatus select { display: none; }
#languageSelectStatus span { cursor: default; }
button { background-color: var(--button-bg); color: var(--button-fg); border: 1px solid var(--border-color); padding: 4px 10px; border-radius: 3px; cursor: pointer; font-weight: normal; transition: background-color 0.1s, border-color 0.1s; font-size: 0.85rem; line-height: 1.2; }
button:hover { background-color: var(--button-hover-bg); }
button:active { background-color: var(--button-active-bg); }
button:disabled { background-color: var(--button-bg) !important; border-color: var(--border-color) !important; color: #888 !important; cursor: not-allowed; opacity: 0.6; }
body.theme-light button:disabled { color: #aaa !important; }
.toolbar button { padding: 3px 6px; }
.toolbar button.primary { background-color: #4a90e2; color: white; border-color: #4a90e2; }
.toolbar button.secondary { background-color: #6c757d; color: white; border-color: #6c757d; }
.toolbar button.danger { background-color: #dc3545; color: white; border-color: #dc3545; }
.toolbar button.primary:hover { background-color: #357abd; }
.toolbar button.secondary:hover { background-color: #5a6268; }
.toolbar button.danger:hover { background-color: #c82333; }
body.theme-light .toolbar button.primary { background-color: #007bff; }
body.theme-light .toolbar button.secondary { background-color: #6c757d; }
body.theme-light .toolbar button.danger { background-color: #dc3545; }
body.theme-light .toolbar button.primary:hover { background-color: #0056b3; }
body.theme-light .toolbar button.secondary:hover { background-color: #545b62; }
body.theme-light .toolbar button.danger:hover { background-color: #bd2130; }
.find-replace-container input[type="text"] { flex: 1; padding: 4px 6px; font-size: 0.85rem; min-width: 120px; border: 1px solid var(--input-border); background-color: var(--input-bg); color: var(--app-fg); border-radius: 2px; }
.find-replace-container input[type="text"]:focus { outline: none; border-color: var(--input-focus-border); box-shadow: 0 0 0 1px var(--input-focus-border); }
.search-actions { display: flex; gap: 4px; }
.search-actions button { padding: 3px 8px; font-size: 0.8rem; }
#closeFindBtn { margin-left: 5px; padding: 2px 6px; font-size: 1rem; line-height: 1; background-color: transparent; border: none; color: var(--app-fg); opacity: 0.7; }
#closeFindBtn:hover { background-color: var(--danger-color); color: white; opacity: 1; }
.CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning { background-position: left bottom; background-repeat: repeat-x; }
.CodeMirror-lint-marker-error { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAABJJREFUCB1j8DNk+M8wrrVfJQARAADO8SKkAX27wQAAAABJRU5ErkJggg=="); }
.CodeMirror-lint-marker-warning { background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAABRJREFUCB1j8Mvg/p+B6f8zVBEBAB59Ek9VRGuSAAAAAElFTkSuQmCC"); }
.CodeMirror-lint-tooltip { background-color: var(--toolbar-bg) !important; border: 1px solid var(--border-color) !important; color: var(--app-fg) !important; padding: 5px 8px !important; border-radius: 3px !important; font-size: 0.85em !important; z-index: 15 !important; box-shadow: 1px 1px 4px rgba(0,0,0,0.2); }
.cm-ai-suggestion { color: #888; font-style: italic; background-color: rgba(128, 128, 128, 0.1); }
.modal { position: fixed; z-index: 200; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); backdrop-filter: blur(2px); display: none; align-items: center; justify-content: center; }
.modal.active { display: flex; }
.modal-content { background-color: var(--modal-bg); color: var(--app-fg); padding: 0; border-radius: 4px; width: 450px; max-width: 90%; box-shadow: 0 5px 15px rgba(0,0,0,0.3); border: 1px solid var(--border-color); overflow: hidden; }
.modal-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; border-bottom: 1px solid var(--border-color); background-color: var(--modal-header-bg); }
.modal-header h3 { margin: 0; font-size: 1.1rem; font-weight: 600; }
.modal-close { color: var(--app-fg); font-size: 22px; font-weight: bold; cursor: pointer; line-height: 1; padding: 0 5px; opacity: 0.7; transition: opacity 0.15s; }
.modal-close:hover, .modal-close:focus { opacity: 1; text-decoration: none; outline: none; }
.modal-body { padding: 20px; }
.form-group { margin-bottom: 15px; }
label { display: block; margin-bottom: 5px; font-weight: 500; font-size: 0.9em; }
input[type="text"], select { box-sizing: border-box; width: 100%; padding: 8px 10px; border-radius: 3px; border: 1px solid var(--input-border); background-color: var(--input-bg); color: var(--app-fg); font-size: 0.95em; }
input[type="text"]:focus, select:focus { outline: none; border-color: var(--input-focus-border); box-shadow: 0 0 0 1px var(--input-focus-border); }
.modal-actions { display: flex; justify-content: flex-end; gap: 10px; padding: 12px 15px; border-top: 1px solid var(--border-color); background-color: var(--modal-header-bg); }
.modal-actions button { font-weight: 500; }
.modal-actions button.primary { background-color: var(--input-focus-border); color: white; border-color: var(--input-focus-border); }
body.theme-light .modal-actions button.primary { color: white; }
.modal-actions button.primary:hover { background-color: darken(var(--input-focus-border), 10%); border-color: darken(var(--input-focus-border), 10%); }
</style>
</head>
<body class="theme-dark"> 

<div class="app-container">


<div class="menu-bar">
<ul class="menu">
<li class="menu-item">
File
<ul class="submenu">
<li class="submenu-item" id="menu-new">New File<kbd>Ctrl+N</kbd></li>
<li class="submenu-item" id="menu-open">Open File...<kbd>Ctrl+O</kbd></li>
<li class="menu-separator"></li>
<li class="submenu-item" id="menu-save" data-enabled="false">Save<kbd>Ctrl+S</kbd></li>
<li class="submenu-item" id="menu-saveas" data-enabled="false">Save As...<kbd>Ctrl+Shift+S</kbd></li>
<li class="menu-separator"></li>
<li class="submenu-item" id="menu-closefile" data-enabled="false">Close File<kbd>Ctrl+W</kbd></li>
</ul>
</li>
<li class="menu-item">
Edit
<ul class="submenu">
<li class="submenu-item" id="menu-undo" data-enabled="false">Undo<kbd>Ctrl+Z</kbd></li>
<li class="submenu-item" id="menu-redo" data-enabled="false">Redo<kbd>Ctrl+Y</kbd></li>
<li class="menu-separator"></li>
<li class="submenu-item" id="menu-find">Find/Replace...<kbd>Ctrl+F</kbd></li>
<li class="menu-separator"></li>
<li class="submenu-item" id="menu-ai-complete">AI Complete<kbd>Alt+\</kbd></li>
</ul>
</li>
<li class="menu-item">
View
<ul class="submenu">
<li class="menu-item"> 
Language ▶ 
<ul class="submenu language-submenu"> 

</ul>
</li>
<li class="submenu-item" id="menu-toggle-linenumbers">Toggle Line Numbers</li>
<li class="submenu-item" id="menu-toggle-wrapping">Toggle Line Wrapping</li>
</ul>
</li>
<li class="menu-item">
Theme
<ul class="submenu" id="theme-menu">

</ul>
</li>
</ul>
</div>


<div class="toolbar">
<button id="toolbar-new" title="New File (Ctrl+N)">New</button>
<button id="toolbar-open" title="Open File (Ctrl+O)">Open</button>
<button id="toolbar-save" title="Save (Ctrl+S)" disabled>Save</button>
<button id="toolbar-find" class="secondary" title="Find & Replace (Ctrl+F)">Find</button>
</div>


<div class="find-replace-container" id="findReplaceContainer">
<input type="text" id="findInput" placeholder="Find...">
<input type="text" id="replaceInput" placeholder="Replace with...">
<div class="search-actions">
<button id="findPrevBtn" class="secondary" title="Find Previous (Shift+Enter)">Prev</button>
<button id="findNextBtn" class="secondary" title="Find Next (Enter)">Next</button>
<button id="replaceBtn" class="secondary" title="Replace Current">Replace</button>
<button id="replaceAllBtn" class="secondary" title="Replace All">Replace All</button>
</div>
<button id="closeFindBtn" title="Close (Esc)">&times;</button>
</div>


<div class="editor-container">
<div class="sidebar">
<h4>Files</h4>
<ul class="file-list" id="fileList"></ul>
</div>
<div class="main-content">
<div id="editor"></div> 
</div>
</div>


<div class="status-bar">
<div id="fileInfo">No file opened</div>
<div id="statusMessage">Ready</div>
<div id="languageSelectStatus">
<span id="languageDisplay">Plain Text</span>

<select id="languageSelect" style="display: none;">
 
 <option value="javascript">JavaScript</option>
 <option value="typescript">TypeScript</option>
 <option value="htmlmixed">HTML</option>
 <option value="css">CSS</option>
 <option value="python">Python</option>
 <option value="java">Java</option>
 <option value="text/x-c++src">C++</option>
 <option value="text/x-csharp">C#</option>
 <option value="php">PHP</option>
 <option value="ruby">Ruby</option>
 <option value="go">Go</option>
 <option value="swift">Swift</option>
 <option value="rust">Rust</option>
 <option value="kotlin">Kotlin</option>
 <option value="scala">Scala</option>
 <option value="sql">SQL</option>
 <option value="shell">Shell Script</option>
 <option value="perl">Perl</option>
 <option value="r">R</option>
 <option value="lua">Lua</option>
 <option value="markdown">Markdown</option>
 <option value="yaml">YAML</option>
 <option value="xml">XML</option>
 <option value="text/plain">Plain Text</option>
</select>
</div>
<div id="cursorPosition">Ln 1, Col 1</div>
</div>

</div> 



<div id="newFileModal" class="modal"> 
<div class="modal-content">
<div class="modal-header">
<h3>Create New File</h3>
<span class="modal-close" id="closeNewFileModal" title="Close">&times;</span>
</div>
<div class="modal-body">
<div class="form-group">
<label for="newFileName">File Name:</label>
<input type="text" id="newFileName" placeholder="e.g., script.js, main.py">
</div>
<div class="form-group">
<label for="newFileLanguage">Language:</label>
<select id="newFileLanguage">
<option value="javascript">JavaScript (.js)</option>
<option value="typescript">TypeScript (.ts)</option>
<option value="htmlmixed">HTML (.html)</option>
<option value="css">CSS (.css)</option>
<option value="python">Python (.py)</option>
<option value="java">Java (.java)</option>
<option value="text/x-c++src">C++ (.cpp)</option>
<option value="text/x-csharp">C# (.cs)</option>
<option value="php">PHP (.php)</option>
<option value="ruby">Ruby (.rb)</option>
<option value="go">Go (.go)</option>
<option value="swift">Swift (.swift)</option>
<option value="rust">Rust (.rs)</option>
<option value="kotlin">Kotlin (.kt)</option>
<option value="scala">Scala (.scala)</option>
<option value="sql">SQL (.sql)</option>
<option value="shell">Shell Script (.sh)</option>
<option value="perl">Perl (.pl)</option>
<option value="r">R (.r)</option>
<option value="lua">Lua (.lua)</option>
<option value="markdown">Markdown (.md)</option>
<option value="yaml">YAML (.yaml, .yml)</option>
<option value="xml">XML (.xml)</option>
<option value="text/plain">Plain Text (.txt)</option>
</select>
</div>
</div>
<div class="modal-actions">
<button id="cancelNewFile" class="secondary">Cancel</button>
<button id="createNewFile" class="primary">Create</button>
</div>
</div>
</div>


<div id="saveAsModal" class="modal"> 
<div class="modal-content">
<div class="modal-header">
<h3>Save File As</h3>
<span class="modal-close" id="closeSaveAsModal" title="Close">&times;</span>
</div>
<div class="modal-body">
<div class="form-group">
<label for="saveAsFileName">File Name:</label>
<input type="text" id="saveAsFileName" placeholder="example.js">
</div>
</div>
<div class="modal-actions">
<button id="cancelSaveAs" class="secondary">Cancel</button>
<button id="confirmSaveAs" class="primary">Save</button>
</div>
</div>
</div>

<script>
// Make linters available globally for CodeMirror addons BEFORE the IIFE
window.JSHINT = JSHINT;
window.CSSLint = CSSLint;
window.HTMLHint = HTMLHint;
window.jsyaml = jsyaml; // Make js-yaml available

(function() { // Start IIFE to encapsulate the editor logic
    'use strict'; // Enable strict mode

    // --- Constants ---
    const LLAMA_API_URL = 'http://localhost:8080/completion'; // <<< Your Llama.cpp server URL
    const AI_COMPLETION_MAX_TOKENS = 128;
    const AI_COMPLETION_STOP_TOKENS = ["\n", "\t", ";", "}", ")", "<|EOT|>", "```"];
    const AI_PROMPT_MAX_CHARS = 2048;
    const STATUS_MESSAGE_DEFAULT = "Ready";
    const STATUS_MESSAGE_DURATION = 3000; // Default duration for temporary messages (ms)
    const MODAL_FOCUS_DELAY = 50; // ms delay for focusing modal inputs
    const LINTABLE_MODES = ['javascript', 'typescript', 'json', 'css', 'htmlmixed', 'yaml'];
    const DEFAULT_LANGUAGE = 'text/plain';
    const DEFAULT_THEME_NAME = "System Dark";

    const APP_THEMES = {
        "System Light": { cm: "default", type: "light" },
        "System Dark": { cm: "dracula", type: "dark" },
        "Dracula": { cm: "dracula", type: "dark" },
        "Material": { cm: "material", type: "dark" },
        "Monokai": { cm: "monokai", type: "dark" },
        "Eclipse": { cm: "eclipse", type: "light" },
        "Base16 Light": { cm: "base16-light", type: "light" },
        "Solarized Light": { cm: "solarized light", type: "light" },
        "Solarized Dark": { cm: "solarized dark", type: "dark" },
    };

    // --- State Variables ---
    let files = []; // Array of file objects { name, content, language, unsaved, handle }
    let currentFileIndex = -1; // Index of the currently active file in the `files` array
    let editor; // CodeMirror instance
    let isAICompleting = false; // Flag to prevent concurrent AI requests
    let activeSuggestionMarker = null; // Reference to the current AI suggestion marker
    let isInsertingAISuggestion = false; // Flag to ignore editor changes during AI insertion
    let currentAppTheme = DEFAULT_THEME_NAME; // Current application theme name
    let statusTimeoutId = null; // Timeout ID for clearing status messages

    // --- DOM Element References (Cached) ---
    const dom = {};

    /** Caches references to frequently used DOM elements. */
    function cacheDOMElements() {
        dom.fileList = document.getElementById("fileList");
        dom.editorContainer = document.getElementById("editor");
        dom.cursorPosition = document.getElementById("cursorPosition");
        dom.fileInfo = document.getElementById("fileInfo");
        dom.languageSelect = document.getElementById("languageSelect");
        dom.languageDisplay = document.getElementById("languageDisplay");
        dom.toolbarSaveBtn = document.getElementById("toolbar-save");
        dom.findReplaceContainer = document.getElementById("findReplaceContainer");
        dom.findInput = document.getElementById("findInput");
        dom.replaceInput = document.getElementById("replaceInput");
        dom.newFileModal = document.getElementById("newFileModal");
        dom.saveAsModal = document.getElementById("saveAsModal");
        dom.newFileNameInput = document.getElementById("newFileName");
        dom.newFileLangSelect = document.getElementById("newFileLanguage");
        dom.saveAsFileNameInput = document.getElementById("saveAsFileName");
        dom.statusMessage = document.getElementById("statusMessage");
        dom.languageSubmenu = document.querySelector('.language-submenu');
        dom.themeMenu = document.getElementById('theme-menu');

        // Menu Items for state toggling
        dom.menuSave = document.getElementById('menu-save');
        dom.menuSaveAs = document.getElementById('menu-saveas');
        dom.menuCloseFile = document.getElementById('menu-closefile');
        dom.menuUndo = document.getElementById('menu-undo');
        dom.menuRedo = document.getElementById('menu-redo');
    }

    // --- Initialization ---
    /** Initializes the CodeMirror editor instance. */
    function initEditor() {
        const initialTheme = APP_THEMES[currentAppTheme];
        editor = CodeMirror(dom.editorContainer, {
            mode: DEFAULT_LANGUAGE,
            theme: initialTheme.cm,
            lineNumbers: true,
            matchBrackets: true,
            autoCloseBrackets: true,
            indentUnit: 2,
            tabSize: 2,
            indentWithTabs: false,
            lineWrapping: false,
            gutters: ["CodeMirror-linenumbers", "CodeMirror-lint-markers"],
            lint: false, // Enable per file based on language
            readOnly: true, // Start read-only until a file is opened
            extraKeys: {
                "Ctrl-Space": "autocomplete",
                "Ctrl-F": () => handleFindMenuClick(),
                "Cmd-F": () => handleFindMenuClick(),
                "Ctrl-H": "replace", // Default CM replace binding
                "Cmd-Option-F": "replace", // Default CM replace binding (Mac)
                "Esc": handleEscapeKey,
                "Alt-\\": handleAICompleteMenuClick,
                "Tab": handleTabKey,
                "Ctrl-S": handleSaveClick,
                "Cmd-S": handleSaveClick,
                "Ctrl-Shift-S": handleSaveAsClick,
                "Cmd-Shift-S": handleSaveAsClick,
                "Ctrl-O": handleOpenFileClick,
                "Cmd-O": handleOpenFileClick,
                "Ctrl-N": handleNewFileClick,
                "Cmd-N": handleNewFileClick,
                "Ctrl-W": handleCloseFileClick,
                "Cmd-W": handleCloseFileClick,
                "Ctrl-Z": () => editor.undo(),
                "Cmd-Z": () => editor.undo(),
                "Ctrl-Y": () => editor.redo(), // Windows/Linux Redo
                "Cmd-Y": () => editor.redo(), // Non-standard Mac Redo (often Shift+Cmd+Z)
                "Shift-Cmd-Z": () => editor.redo(), // Standard Mac Redo
            }
        });

        editor.on("cursorActivity", handleCursorActivity);
        editor.on("change", handleEditorChange);
        editor.on("changes", updateUndoRedoState); // Update undo/redo state on any change batches
    }

    /** Initializes the application: caches DOM, sets up editor, themes, menus, listeners. */
    function initApp() {
        cacheDOMElements();
        initEditor();
        applyAppTheme(currentAppTheme); // Apply initial theme to body/UI
        populateLanguageMenu();
        populateThemeMenu();
        setupEventListeners();
        updateUIForFileStatus(); // Initial UI state (no file open)
        setStatusMessage(STATUS_MESSAGE_DEFAULT);
    }

    // --- Helper Functions ---

    /** Sets the status bar message. */
    function setStatusMessage(message = STATUS_MESSAGE_DEFAULT, isError = false, duration = 0) {
        // Clear any existing timeout
        if (statusTimeoutId) {
            clearTimeout(statusTimeoutId);
            statusTimeoutId = null;
        }

        if (!dom.statusMessage) return; // Guard against early calls
        dom.statusMessage.textContent = message;
        dom.statusMessage.style.color = isError ? "var(--danger-color)" : "var(--app-fg)";
        dom.statusMessage.style.fontWeight = isError ? "bold" : "normal";
        dom.statusMessage.title = message; // Set title for long messages

        // Set a new timeout if duration is specified
        if (duration > 0) {
            statusTimeoutId = setTimeout(() => {
                // Clear only if the message hasn't changed in the meantime
                if (dom.statusMessage.textContent === message) {
                    setStatusMessage(STATUS_MESSAGE_DEFAULT); // Reset to default
                }
                statusTimeoutId = null;
            }, duration);
        }
    }

    /** Enables or disables a menu item visually and functionally. */
    function setMenuItemEnabled(menuItemElement, enabled) {
        if (!menuItemElement) return;
        menuItemElement.classList.toggle('disabled', !enabled);
        menuItemElement.dataset.enabled = enabled ? 'true' : 'false';
    }

    /** Opens a modal dialog. */
    function openModal(modalElement) {
        if (!modalElement) return;
        clearActiveSuggestion(false); // Dismiss suggestion when opening any modal
        modalElement.classList.add('active');
        // Focus the first input/select element inside the modal body
        const firstInput = modalElement.querySelector('.modal-body input[type="text"], .modal-body select');
        if (firstInput) {
            setTimeout(() => {
                firstInput.focus();
                if (firstInput.select && typeof firstInput.select === 'function') {
                    try { firstInput.select(); } catch (e) { /* Ignore selection errors */ }
                }
            }, MODAL_FOCUS_DELAY);
        }
    }

    /** Closes a modal dialog. */
    function closeModal(modalElement) {
        if (!modalElement) return;
        modalElement.classList.remove('active');
        if (editor) editor.focus(); // Return focus to the editor
    }

    // --- UI Update Functions ---

    /** Updates the cursor position display in the status bar. */
    function handleCursorActivity() {
        if (!editor || !dom.cursorPosition) return;
        const cursor = editor.getCursor();
        dom.cursorPosition.textContent = `Ln ${cursor.line + 1}, Col ${cursor.ch + 1}`;

        // Clear suggestion if cursor moves outside its bounds
        if (activeSuggestionMarker) {
            const markerRange = activeSuggestionMarker.find();
            if (markerRange) {
                const currentCursor = editor.getCursor();
                if (CodeMirror.cmpPos(currentCursor, markerRange.from) < 0 || CodeMirror.cmpPos(currentCursor, markerRange.to) > 0) {
                    clearActiveSuggestion(false); // Cursor moved out
                }
            } else {
                clearActiveSuggestion(false); // Marker somehow removed externally
            }
        }
    }

    /** Handles changes in the editor content, marks file as unsaved. */
    function handleEditorChange(cm, change) {
        if (isInsertingAISuggestion) return; // Ignore changes during AI suggestion insertion
        if (activeSuggestionMarker) clearActiveSuggestion(false); // Clear suggestion on any user typing

        // Mark file as unsaved only on direct user input or relevant actions
        if (currentFileIndex >= 0 && files[currentFileIndex] && !files[currentFileIndex].unsaved) {
            // Check origin: '+input', 'paste', 'delete', etc. Avoid 'setValue', '*lint*', AI actions.
            if (change.origin && !['setValue', '*lint*', '+AIClear', '+AICompletion'].includes(change.origin)) {
                files[currentFileIndex].unsaved = true;
                updateFileList();
                updateFileInfo();
                updateSaveButtonState();
            }
        }
    }

    /** Updates the enabled state of Undo/Redo menu items. */
    function updateUndoRedoState() {
        if (!editor || !dom.menuUndo || !dom.menuRedo) return;
        const history = editor.historySize();
        setMenuItemEnabled(dom.menuUndo, history.undo > 0);
        setMenuItemEnabled(dom.menuRedo, history.redo > 0);
    }

    /** Rerenders the file list in the sidebar. */
    function updateFileList() {
        if (!dom.fileList) return;
        dom.fileList.innerHTML = ""; // Clear existing items

        if (files.length === 0) {
            const li = document.createElement("li");
            li.textContent = "No files open";
            li.style.cssText = "padding: 10px; color: var(--app-fg); opacity: 0.6; font-size: 0.85rem; text-align: center;";
            dom.fileList.appendChild(li);
            return;
        }

        files.forEach((file, index) => {
            const li = document.createElement("li");
            li.className = `file-item ${index === currentFileIndex ? "active" : ""}`;
            li.title = file.name;
            li.dataset.index = index;
            li.onclick = () => openFileByIndex(index);

            const nameSpan = document.createElement("span");
            nameSpan.className = "file-name";
            nameSpan.textContent = file.name;
            if (file.unsaved) {
                const unsavedIndicator = document.createElement("span");
                unsavedIndicator.className = "unsaved-indicator";
                unsavedIndicator.textContent = " *";
                unsavedIndicator.title = "Unsaved changes";
                nameSpan.appendChild(unsavedIndicator);
            }

            const removeBtn = document.createElement("button");
            removeBtn.className = "file-remove";
            removeBtn.innerHTML = "&times;";
            removeBtn.title = `Close ${file.name}`;
            removeBtn.dataset.index = index;
            removeBtn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering li.onclick
                removeFile(index);
            };

            li.appendChild(nameSpan);
            li.appendChild(removeBtn);
            dom.fileList.appendChild(li);
        });
    }

    /** Updates the file name and language display in the status bar. */
    function updateFileInfo() {
        if (!dom.fileInfo || !dom.languageDisplay || !dom.languageSelect) return;
        if (currentFileIndex >= 0 && files[currentFileIndex]) {
            const file = files[currentFileIndex];
            dom.fileInfo.textContent = `${file.name}${file.unsaved ? "*" : ""}`;
            const langOption = dom.languageSelect.querySelector(`option[value="${file.language}"]`);
            const langDisplayText = langOption ? langOption.text : file.language;
            dom.languageDisplay.textContent = langDisplayText;
            dom.languageDisplay.title = `Language: ${langDisplayText}`;
            dom.languageSelect.value = file.language; // Keep hidden select synced
        } else {
            dom.fileInfo.textContent = "No file opened";
            dom.languageDisplay.textContent = "Plain Text";
            dom.languageDisplay.title = `Language: Plain Text`;
            dom.languageSelect.value = DEFAULT_LANGUAGE;
            if (dom.cursorPosition) dom.cursorPosition.textContent = `Ln 1, Col 1`;
        }
    }

    /** Updates the enabled state of Save/Save As buttons and menu items. */
    function updateSaveButtonState() {
        if (!dom.toolbarSaveBtn || !dom.menuSave || !dom.menuSaveAs || !dom.menuCloseFile) return;
        const hasActiveFile = currentFileIndex >= 0 && files[currentFileIndex];
        const isUnsaved = hasActiveFile && files[currentFileIndex].unsaved;

        dom.toolbarSaveBtn.disabled = !isUnsaved;
        setMenuItemEnabled(dom.menuSave, isUnsaved);
        setMenuItemEnabled(dom.menuSaveAs, hasActiveFile);
        setMenuItemEnabled(dom.menuCloseFile, hasActiveFile);
    }

    /** Updates all UI elements related to the current file's status. */
    function updateUIForFileStatus() {
        updateFileList();
        updateFileInfo();
        updateSaveButtonState();
        updateLanguageMenuSelection(); // Update language menu checkmark
        updateUndoRedoState(); // History changes with file content/switch
    }

    // --- File Management Logic ---

    /** Sets the active file, updating the editor content and UI. */
    function setActiveFile(index) {
        console.log(`Setting active file to index: ${index}`);
        clearActiveSuggestion(false); // Clear suggestion when switching files

        if (!editor) {
            console.error("Editor not initialized, cannot set active file.");
            return;
        }

        // Handle case where no file should be active
        if (index < 0 || index >= files.length) {
            currentFileIndex = -1;
            editor.setValue("");
            editor.clearHistory();
            editor.setOption("mode", DEFAULT_LANGUAGE);
            editor.setOption("lint", false);
            editor.setOption("readOnly", true);
            console.log("No file active. Editor cleared and set to read-only.");
            updateUIForFileStatus();
            return;
        }

        // Avoid redundant work if the index is already active
        if (index === currentFileIndex) {
            console.log(`File at index ${index} is already active.`);
            return;
        }

        currentFileIndex = index;
        const file = files[currentFileIndex];

        editor.operation(() => {
            editor.setOption("readOnly", false); // Ensure editor is editable
            editor.setValue(file.content);
            editor.setOption("mode", file.language);
            editor.setOption("lint", LINTABLE_MODES.includes(file.language));
            console.log(`Switched to file "${file.name}". Mode: ${file.language}, Linting: ${editor.getOption("lint")}`);
        });
        editor.clearHistory(); // Clear history for the new file content
        editor.focus();
        updateUIForFileStatus(); // Update all relevant UI parts
    }

    /** Opens a file by its index in the `files` array. */
    function openFileByIndex(index) {
        setActiveFile(index);
    }

    /** Creates a new file object and adds it to the list. */
    function createNewFileEntry(name, language) {
        // Basic validation
        if (!name) {
            setStatusMessage("File name cannot be empty.", true, STATUS_MESSAGE_DURATION);
            alert("File name cannot be empty.");
            return false; // Indicate failure
        }
        if (files.some(f => f.name === name)) {
            setStatusMessage(`File "${name}" already exists.`, true, STATUS_MESSAGE_DURATION);
            alert(`A file named "${name}" already exists.`);
            return false; // Indicate failure
        }

        const newFile = {
            name: name,
            content: "",
            language: language,
            unsaved: true, // New files start as unsaved
            handle: null // No file system handle initially
        };
        files.push(newFile);
        clearActiveSuggestion(false); // Clear suggestion before switching
        setActiveFile(files.length - 1); // Activate the newly created file
        setStatusMessage(`Created "${name}"`, false, STATUS_MESSAGE_DURATION);
        return true; // Indicate success
    }

    /** Removes a file from the list, prompting if unsaved. */
    function removeFile(index) {
        if (index < 0 || index >= files.length) return; // Invalid index

        const fileToRemove = files[index];

        // Confirm closing if there are unsaved changes
        if (fileToRemove.unsaved) {
            if (!window.confirm(`Discard unsaved changes in "${fileToRemove.name}"?`)) {
                return; // User cancelled
            }
        }

        const closingCurrent = (index === currentFileIndex);
        const closedFileName = fileToRemove.name;
        files.splice(index, 1); // Remove the file from the array

        let nextIndex = -1; // Default to no file active
        if (files.length > 0) {
            if (closingCurrent) {
                // If closing the active file, try to select the previous one, or the new first one
                nextIndex = Math.max(0, index - 1);
            } else {
                // If closing a non-active file, adjust the current index if it was after the removed file
                nextIndex = (currentFileIndex > index) ? currentFileIndex - 1 : currentFileIndex;
            }
        }

        clearActiveSuggestion(false); // Clear suggestion before switching
        setActiveFile(nextIndex); // Activate the determined next file (or none)
        setStatusMessage(`Closed "${closedFileName}"`, false, STATUS_MESSAGE_DURATION);
    }

    // --- File Saving/Loading Helpers ---

    /** Gets the appropriate MIME type for a given language mode. */
    function getMimeType(language) {
        // (Map language modes to MIME types - same as original)
        switch (language) {
            case "javascript": return "text/javascript";
            case "typescript": return "text/typescript";
            case "htmlmixed": return "text/html";
            case "css": return "text/css";
            case "xml": return "application/xml";
            case "python": return "text/x-python";
            case "java": return "text/x-java-source";
            case "text/x-c++src": return "text/x-c++src";
            case "text/x-csharp": return "text/x-csharp";
            case "php": return "application/x-httpd-php";
            case "ruby": return "text/x-ruby";
            case "go": return "text/x-go";
            case "swift": return "text/x-swift";
            case "rust": return "text/rust";
            case "kotlin": return "text/x-kotlin";
            case "scala": return "text/x-scala";
            case "sql": return "application/sql";
            case "shell": return "application/x-sh";
            case "perl": return "text/x-perl";
            case "r": return "text/x-r-source";
            case "lua": return "text/x-lua";
            case "markdown": return "text/markdown";
            case "yaml": return "application/x-yaml";
            case "json": return "application/json";
            case "text/plain": default: return "text/plain";
        }
    }

    /** Suggests a file extension based on the language mode. */
    function getSuggestedExtension(language) {
         // (Map language modes to extensions - same as original)
        switch (language) {
            case "javascript": return ".js";
            case "typescript": return ".ts";
            case "htmlmixed": return ".html";
            case "css": return ".css";
            case "xml": return ".xml";
            case "python": return ".py";
            case "java": return ".java";
            case "text/x-c++src": return ".cpp";
            case "text/x-csharp": return ".cs";
            case "php": return ".php";
            case "ruby": return ".rb";
            case "go": return ".go";
            case "swift": return ".swift";
            case "rust": return ".rs";
            case "kotlin": return ".kt";
            case "scala": return ".scala";
            case "sql": return ".sql";
            case "shell": return ".sh";
            case "perl": return ".pl";
            case "r": return ".r";
            case "lua": return ".lua";
            case "markdown": return ".md";
            case "yaml": return ".yaml";
            case "json": return ".json";
            case "text/plain": default: return ".txt";
        }
    }

    /** Determines the language mode from a file name extension. */
    function getLanguageFromFileName(name) {
        if (!name || name.indexOf('.') === -1) return DEFAULT_LANGUAGE;
        const extension = name.split('.').pop().toLowerCase();
        // (Map extensions to language modes - same as original)
        switch (extension) {
            case "js": case "mjs": case "cjs": return "javascript";
            case "ts": case "tsx": return "typescript";
            case "html": case "htm": return "htmlmixed";
            case "css": return "css";
            case "xml": case "svg": case "rss": case "atom": return "xml";
            case "py": case "pyw": return "python";
            case "java": return "java";
            case "c": case "h": return "text/x-csrc"; // Added C
            case "cpp": case "cxx": case "hpp": case "hxx": return "text/x-c++src";
            case "cs": return "text/x-csharp";
            case "php": case "php3": case "php4": case "php5": case "phtml": return "php";
            case "rb": return "ruby";
            case "go": return "go";
            case "swift": return "swift";
            case "rs": return "rust";
            case "kt": case "kts": return "kotlin";
            case "scala": return "scala";
            case "sql": return "sql";
            case "sh": case "bash": case "zsh": return "shell";
            case "pl": case "pm": return "perl";
            case "r": return "r";
            case "lua": return "lua";
            case "md": case "markdown": return "markdown";
            case "yaml": case "yml": return "yaml";
            case "json": return "application/json"; // Often fine to just use JS mode for syntax
            case "txt": default: return DEFAULT_LANGUAGE;
        }
    }

    /** Generates the 'types' array for the File System Access API file pickers. */
    function getFilePickerTypes() {
        // (Define file picker types - same as original)
        return [
            { description: 'JavaScript', accept: { 'text/javascript': ['.js', '.mjs', '.cjs'] } },
            { description: 'TypeScript', accept: { 'text/typescript': ['.ts', '.tsx'] } },
            { description: 'HTML', accept: { 'text/html': ['.html', '.htm'] } },
            { description: 'CSS', accept: { 'text/css': ['.css'] } },
            { description: 'Python', accept: { 'text/x-python': ['.py', '.pyw'] } },
            { description: 'Java', accept: { 'text/x-java-source': ['.java'] } },
            { description: 'C/C++', accept: { 'text/x-csrc': ['.c', '.h'], 'text/x-c++src': ['.cpp', '.cxx', '.hpp', '.hxx'] } },
            { description: 'C#', accept: { 'text/x-csharp': ['.cs'] } },
            { description: 'PHP', accept: { 'application/x-httpd-php': ['.php', '.phtml'] } },
            { description: 'Ruby', accept: { 'text/x-ruby': ['.rb'] } },
            { description: 'Go', accept: { 'text/x-go': ['.go'] } },
            { description: 'Swift', accept: { 'text/x-swift': ['.swift'] } },
            { description: 'Rust', accept: { 'text/rust': ['.rs'] } },
            { description: 'Kotlin', accept: { 'text/x-kotlin': ['.kt', '.kts'] } },
            { description: 'Scala', accept: { 'text/x-scala': ['.scala'] } },
            { description: 'SQL', accept: { 'application/sql': ['.sql'] } },
            { description: 'Shell Script', accept: { 'application/x-sh': ['.sh', '.bash', '.zsh'] } },
            { description: 'Perl', accept: { 'text/x-perl': ['.pl', '.pm'] } },
            { description: 'R Script', accept: { 'text/x-r-source': ['.r'] } },
            { description: 'Lua', accept: { 'text/x-lua': ['.lua'] } },
            { description: 'Markdown', accept: { 'text/markdown': ['.md', '.markdown'] } },
            { description: 'YAML', accept: { 'application/x-yaml': ['.yaml', '.yml'] } },
            { description: 'XML', accept: { 'application/xml': ['.xml', '.svg', '.rss', '.atom'] } },
            { description: 'JSON', accept: { 'application/json': ['.json'] } },
            { description: 'Text Files', accept: { 'text/plain': ['.txt'] } },
            { description: 'All Files', accept: {'*/*': []} }
        ];
    }

    /** Triggers a file download as a fallback mechanism. */
    function triggerDownload(filename, content, language) {
        const blob = new Blob([content], { type: getMimeType(language) });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        console.log(`Download initiated for "${filename}".`);
    }


    // --- File Saving/Loading (Core Logic) ---

    /** Saves the current file, handling 'Save As' logic and FSA API/fallback. */
    async function saveFile(isSaveAs = false) {
        clearActiveSuggestion(false);
        if (!editor) return; // Should not happen if UI is managed correctly

        if (currentFileIndex < 0 || !files[currentFileIndex]) {
            console.error("Save attempt failed: No active file.");
            setStatusMessage("No active file to save", true, STATUS_MESSAGE_DURATION);
            return;
        }

        const file = files[currentFileIndex];
        file.content = editor.getValue(); // Get current content *before* potential name/language changes

        let currentHandle = file.handle;
        let suggestedName = file.name;
        const originalLanguage = file.language; // Store original language before potential changes
        let targetLanguage = file.language; // Language intended for saving

        if (isSaveAs) {
            suggestedName = dom.saveAsFileNameInput.value.trim();
            if (!suggestedName) {
                alert("Please enter a file name.");
                dom.saveAsFileNameInput.focus();
                return; // Keep Save As modal open
            }
            // Infer language from the new name provided in the modal
            targetLanguage = getLanguageFromFileName(suggestedName);
        } else if (!file.name) {
            // If 'Save' is clicked on a new, unnamed file, treat it as 'Save As'
            console.log("Save clicked on new file, redirecting to Save As flow.");
            handleSaveAsClick();
            return;
        }

        setStatusMessage(`Saving "${suggestedName}"...`);

        try {
            let fileHandleToUse;
            // Use File System Access API if available
            if (window.showSaveFilePicker) {
                 const pickerOptions = {
                    suggestedName: suggestedName,
                    types: getFilePickerTypes()
                 };

                 // Force picker for 'Save As' or if no handle exists yet
                 if (isSaveAs || !currentHandle) {
                    fileHandleToUse = await window.showSaveFilePicker(pickerOptions);
                    // Update file state based on picker result *only after* successful selection
                    file.handle = fileHandleToUse; // Store the handle
                    file.name = fileHandleToUse.name;
                    targetLanguage = getLanguageFromFileName(file.name); // Re-confirm language from actual saved name
                 } else {
                    fileHandleToUse = currentHandle; // Use existing handle for regular save
                 }

                 // Write the file content
                 const writable = await fileHandleToUse.createWritable();
                 await writable.write(file.content); // Write the original content fetched earlier
                 await writable.close();

                 console.log(`File "${file.name}" saved successfully via FSA API.`);

            } else { // Fallback to legacy download
                console.log("FSA API not supported. Using download fallback.");
                // If 'Save As', update the file name and target language based on modal input
                if (isSaveAs) {
                    file.name = suggestedName;
                    // targetLanguage was already set based on suggestedName
                }
                triggerDownload(file.name, file.content, targetLanguage);
            }

            // --- Post-Save Updates (Common to both FSA and Fallback) ---
            file.language = targetLanguage; // Update the file's language state
            file.unsaved = false;
            setFileLanguage(file.language, true); // Update editor mode & UI (mark as non-save call)
            setStatusMessage(`Saved ${file.name}`, false, STATUS_MESSAGE_DURATION);
            if (isSaveAs) closeModal(dom.saveAsModal); // Close modal on successful Save As

        } catch (err) {
            // Handle user cancellation specifically
            if (err.name === 'AbortError') {
                console.log("Save operation cancelled by user.");
                setStatusMessage("Save cancelled", false, STATUS_MESSAGE_DURATION);
                // No need to restore original language/name here as state wasn't committed yet
                if (isSaveAs) closeModal(dom.saveAsModal); // Close modal if 'Save As' was cancelled
                return;
            }

            // Handle other errors
            console.error("Error saving file:", err);
            setStatusMessage(`Save failed: ${err.message}`, true, 5000);

            // Important: If Save As failed *after* the picker but *before* writing,
            // the file object might have the new name/handle. We should *not* revert
            // the language here, as the failure wasn't related to the language change itself.
            // The file object remains in its pre-save state essentially.
            // Let's just ensure the Save As modal closes if it was open.
             if (isSaveAs) closeModal(dom.saveAsModal);
        }
    }

    /** Opens a file using FSA API or fallback input element. */
    async function openFile() {
        console.log("Attempting to open file...");
        clearActiveSuggestion(false);

        try {
            let fileHandle;
            let fileData;

            // Use File System Access API if available
            if (window.showOpenFilePicker) {
                console.log("Using showOpenFilePicker API.");
                [fileHandle] = await window.showOpenFilePicker({ types: getFilePickerTypes(), multiple: false });
                fileData = await fileHandle.getFile();
                console.log(`File selected via FSA: "${fileData.name}"`);
            } else {
                // Fallback to legacy input element
                console.log("Using legacy <input type='file'> fallback.");
                fileData = await triggerLegacyFileOpen(); // This promise resolves with the file object
                fileHandle = null; // No handle with legacy method
                if (!fileData) return; // User cancelled legacy dialog
                 console.log(`File selected via legacy input: "${fileData.name}"`);
            }

            await handleFileOpenResult(fileData, fileHandle);

        } catch (err) {
            if (err.name === 'AbortError') {
                console.log("Open file operation cancelled by user.");
                setStatusMessage("Open cancelled", false, STATUS_MESSAGE_DURATION);
            } else {
                console.error("Error opening file:", err);
                setStatusMessage(`Open failed: ${err.message}`, true, 5000);
            }
        }
    }

    /** Reads file content using FileReader (for legacy open). */
    function readFileContentLegacy(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result);
            reader.onerror = (error) => {
                console.error("FileReader error:", error);
                reject(new Error(`Error reading file "${file.name}"`));
            };
            reader.readAsText(file);
        });
    }

    /** Prompts the user to select a file using the legacy input method. */
     function triggerLegacyFileOpen() {
        return new Promise((resolve, reject) => {
             const input = document.createElement("input");
             input.type = "file";
             const allExtensions = getFilePickerTypes()
                 .flatMap(type => Object.values(type.accept || {}).flat())
                 .filter((ext, index, self) => ext && self.indexOf(ext) === index); // Unique extensions
             input.accept = allExtensions.join(',') || "*/*"; // Comma-separated list

             input.onchange = (e) => {
                 if (e.target.files && e.target.files.length > 0) {
                     resolve(e.target.files[0]); // Resolve with the selected file object
                 } else {
                     resolve(null); // Resolve with null if no file selected (user cancelled)
                 }
                 // Clean up the input element after use
                 document.body.removeChild(input);
             };

             // Handle cancellation more directly if possible (though not perfectly reliable)
             input.oncancel = () => { // May not fire consistently across browsers
                console.log("Legacy file input cancelled via event.");
                 resolve(null);
                 if (input.parentNode) document.body.removeChild(input);
             };

             // Hide the input element
             input.style.display = 'none';
             document.body.appendChild(input);
             input.click();
         });
     }


    /** Processes the selected file (from FSA or legacy) */
    async function handleFileOpenResult(fileData, fileHandle) {
         // Check if the exact file (by handle if available) is already open
        if (fileHandle) {
            const existingIndexByHandle = files.findIndex(f => f.handle && typeof f.handle.isSameEntry === 'function' && f.handle.isSameEntry(fileHandle));
            if (existingIndexByHandle !== -1) {
                console.log(`Switching to already open file (by handle): "${fileData.name}"`);
                setActiveFile(existingIndexByHandle);
                setStatusMessage(`Switched to ${fileData.name}`, false, STATUS_MESSAGE_DURATION);
                return;
            }
        }

        // Check if a file with the same name is already open
        const existingIndexByName = files.findIndex(f => f.name === fileData.name);
        if (existingIndexByName !== -1) {
            if (confirm(`"${fileData.name}" is already open. Reload it from disk? (Unsaved changes will be lost)`)) {
                // Reload the existing file entry
                const content = fileHandle ? await fileData.text() : await readFileContentLegacy(fileData);
                files[existingIndexByName].content = content;
                files[existingIndexByName].unsaved = false;
                files[existingIndexByName].handle = fileHandle; // Update handle (might be null for legacy)
                files[existingIndexByName].language = getLanguageFromFileName(fileData.name);
                setActiveFile(existingIndexByName); // Reloads content and mode in editor
                console.log(`Reloaded "${fileData.name}" from disk.`);
                setStatusMessage(`Reloaded ${fileData.name}`, false, STATUS_MESSAGE_DURATION);
            } else {
                // User chose not to reload, just switch focus
                console.log(`Did not reload "${fileData.name}". Switching focus.`);
                setActiveFile(existingIndexByName);
                setStatusMessage(`Kept existing ${fileData.name}`, false, STATUS_MESSAGE_DURATION);
            }
            return; // Stop processing, handled existing file
        }

        // Open as a new file entry
        const content = fileHandle ? await fileData.text() : await readFileContentLegacy(fileData);
        const language = getLanguageFromFileName(fileData.name);
        const newFile = {
            name: fileData.name,
            content: content,
            language: language,
            unsaved: false,
            handle: fileHandle
        };
        files.push(newFile);
        setActiveFile(files.length - 1); // Activate the newly opened file
        console.log(`Opened "${fileData.name}" as a new file.`);
        setStatusMessage(`Opened ${fileData.name}`, false, STATUS_MESSAGE_DURATION);
     }


    // --- Find & Replace Logic ---

    /** Toggles the visibility of the find/replace bar. */
    function toggleFindReplace(show) {
        if (!editor || !dom.findReplaceContainer) return;
        clearActiveSuggestion(false); // Close suggestion when opening find/replace

        const isVisible = dom.findReplaceContainer.style.display === 'flex';

        if (show && isVisible) {
            // If already open and asked to show, just focus the input
            dom.findInput.focus();
            dom.findInput.select();
            return;
        }

        dom.findReplaceContainer.style.display = show ? "flex" : "none";

        if (show) {
            const selection = editor.getSelection();
            if (selection) dom.findInput.value = selection;
            dom.findInput.focus();
            dom.findInput.select();
            // Reset search state? (Could keep last search if preferred)
        } else {
            editor.focus(); // Return focus to editor when closing
        }
    }

    /** Performs a find operation (next or previous). */
    function find(reverse = false) {
        if (!editor) return;
        const query = dom.findInput.value;
        if (!query) {
            setStatusMessage("Find: Please enter search text.", true, STATUS_MESSAGE_DURATION);
            return;
        }
        // Future: Add case-sensitivity option from a checkbox
        const caseSensitive = false;
        setStatusMessage(`Finding "${query}"...`);

        const searchCursor = editor.getSearchCursor(query,
            reverse ? editor.getCursor("from") : editor.getCursor("to"),
            { caseFold: !caseSensitive, reverse: reverse }
        );

        if (!searchCursor.find(reverse)) {
            // Wrap search if not found from current position
            setStatusMessage(`"${query}" not found from cursor. Wrapping search...`, false, 1500);
            const startPos = reverse ? CodeMirror.Pos(editor.lastLine()) : CodeMirror.Pos(0, 0);
            const wrapCursor = editor.getSearchCursor(query, startPos, { caseFold: !caseSensitive, reverse: reverse });
            if (!wrapCursor.find(reverse)) {
                setStatusMessage(`"${query}" not found in document.`, true, STATUS_MESSAGE_DURATION);
                return;
            }
            // Found after wrapping
            editor.setSelection(wrapCursor.from(), wrapCursor.to());
            editor.scrollIntoView({ from: wrapCursor.from(), to: wrapCursor.to() }, 50);
            setStatusMessage(`Found "${query}" (wrapped).`, false, STATUS_MESSAGE_DURATION);
        } else {
            // Found next/prev match
            editor.setSelection(searchCursor.from(), searchCursor.to());
            editor.scrollIntoView({ from: searchCursor.from(), to: searchCursor.to() }, 50);
            setStatusMessage(`Found "${query}".`, false, STATUS_MESSAGE_DURATION);
        }
        dom.findInput.focus(); // Keep focus in find input
    }

    /** Replaces the current selection or finds the next match. */
    function replace() {
        if (!editor) return;
        const query = dom.findInput.value;
        const replacement = dom.replaceInput.value;
        const selection = editor.getSelection();
        // Future: Add case-sensitivity option
        const caseSensitive = false;

        // Check if the current selection exactly matches the query
        const selectionMatches = selection &&
            (caseSensitive ? selection === query : selection.toLowerCase() === query.toLowerCase());

        if (selectionMatches) {
            editor.replaceSelection(replacement, "around");
            setStatusMessage(`Replaced "${query}". Finding next...`, false, 1500);
            find(false); // Find the next occurrence automatically
        } else {
            // If selection doesn't match, just find the next instance
            setStatusMessage(`Selection doesn't match. Finding next "${query}"...`, false, 1500);
            find(false);
        }
        dom.replaceInput.focus(); // Keep focus in replace input
    }

    /** Replaces all occurrences of the query in the document. */
    function replaceAll() {
        if (!editor) return;
        const query = dom.findInput.value;
        const replacement = dom.replaceInput.value;
        if (!query) {
            setStatusMessage("Replace All: Please enter search text.", true, STATUS_MESSAGE_DURATION);
            return;
        }
        // Future: Add case-sensitivity option
        const caseSensitive = false;
        let count = 0;

        // Perform replace all within a single editor operation for efficiency and single undo
        editor.operation(() => {
            const cursor = editor.getSearchCursor(query, CodeMirror.Pos(0, 0), { caseFold: !caseSensitive });
            while (cursor.findNext()) {
                cursor.replace(replacement);
                count++;
            }
        });

        setStatusMessage(`Replaced ${count} instance(s) of "${query}".`, false, STATUS_MESSAGE_DURATION);
        editor.focus(); // Return focus to the editor
    }


    // --- Theme Management ---

    /** Applies the selected theme to the editor and the overall UI. */
    function applyAppTheme(themeName) {
        const themeConfig = APP_THEMES[themeName];
        if (!themeConfig) {
            console.error("Unknown theme:", themeName);
            return;
        }

        // 1. Set CodeMirror editor theme
        if (editor) {
            editor.setOption("theme", themeConfig.cm);
        }

        // 2. Set body class for general UI styles
        document.body.className = `theme-${themeConfig.type}`; // e.g., 'theme-light' or 'theme-dark'

        // 3. Update state and provide feedback
        currentAppTheme = themeName;
        console.log(`Applied theme: ${themeName} (UI: ${themeConfig.type}, Editor: ${themeConfig.cm})`);
        setStatusMessage(`Theme set to ${themeName}`, false, 2000); // Shorter duration for theme change

        updateThemeMenuSelection(); // Update checkmark in the theme menu
    }

    /** Populates the theme selection submenu. */
    function populateThemeMenu() {
        if (!dom.themeMenu) return;
        dom.themeMenu.innerHTML = ''; // Clear existing options
        Object.keys(APP_THEMES).forEach(themeName => {
            const li = document.createElement('li');
            li.className = 'submenu-item theme-option';
            li.textContent = themeName;
            li.dataset.themeName = themeName; // Store name for identification
            li.onclick = () => applyAppTheme(themeName);
            dom.themeMenu.appendChild(li);
        });
        updateThemeMenuSelection(); // Set initial checkmark based on default theme
    }

    /** Updates the checkmark indicator in the theme selection submenu. */
    function updateThemeMenuSelection() {
        if (!dom.themeMenu) return;
        const items = dom.themeMenu.querySelectorAll('.theme-option');
        items.forEach(item => {
            const themeName = item.dataset.themeName;
            if (themeName === currentAppTheme) {
                item.textContent = `✓ ${themeName}`; // Add checkmark
                item.style.fontWeight = 'bold';
            } else {
                item.textContent = themeName; // Remove checkmark
                item.style.fontWeight = 'normal';
            }
        });
    }

    // --- AI Suggestion Management ---

    /** Clears the currently active AI suggestion marker and optionally removes text. */
    function clearActiveSuggestion(accepted = false) {
        if (!activeSuggestionMarker) return; // No active suggestion

        const marker = activeSuggestionMarker;
        const markerId = marker.id || Date.now(); // Use ID or timestamp for logging
        activeSuggestionMarker = null; // Clear the state variable *first*

        console.log(`Clearing suggestion marker ${markerId}. Accepted: ${accepted}`);

        const range = marker.find(); // Get the range before clearing the visual marker
        marker.clear(); // Remove the visual styling/marker from the editor

        if (!accepted && range) {
            // If rejected and the range still exists, remove the text programmatically
            editor.replaceRange("", range.from, range.to, "+AIClear"); // Use special origin
            console.log(`Suggestion marker ${markerId} rejected and text removed.`);
            setStatusMessage("Suggestion dismissed", false, 2000);
        } else if (accepted && range) {
            // If accepted, the text stays. Move the cursor to the end of the accepted text.
            editor.setCursor(range.to);
            setStatusMessage("Suggestion accepted", false, 2000);
            console.log(`Suggestion marker ${markerId} accepted.`);
        } else {
            // Catch-all for other cases (e.g., user manually deleted text)
            console.log(`Suggestion marker ${markerId} dismissed (marker cleared).`);
             // Only show dismiss message if it wasn't accepted
             if (!accepted) setStatusMessage("Suggestion dismissed", false, 2000);
        }

        if (editor) editor.focus(); // Ensure editor regains focus
    }

    /** Fetches AI completion from the backend API. */
    async function fetchAICompletion(prompt) {
        setStatusMessage("AI thinking...");
        console.log("--- Sending Prompt to AI ---");
        console.log(prompt);

        try {
            const requestBody = {
                prompt: prompt,
                n_predict: AI_COMPLETION_MAX_TOKENS,
                temperature: 0.7, // Example temperature
                stop: AI_COMPLETION_STOP_TOKENS
            };
            console.log("--- Sending Request Body ---");
            console.log(JSON.stringify(requestBody, null, 2));

            const response = await fetch(LLAMA_API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                 const errorText = await response.text();
                 console.error("--- API Error Response ---");
                 console.error(errorText);
                throw new Error(`API request failed: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            console.log("--- Raw Response Data ---");
            console.log(JSON.stringify(data, null, 2));

            if (data && data.content) {
                // Basic cleaning: remove leading/trailing whitespace.
                let completionText = data.content.trim();

                // Optional: Remove stop words if they appear exactly at the end
                for (const stopWord of AI_COMPLETION_STOP_TOKENS) {
                    if (completionText.endsWith(stopWord)) {
                        completionText = completionText.slice(0, -stopWord.length).trimEnd();
                        console.log(`Removed stop word "${stopWord}" from end.`);
                    }
                }
                 // Avoid returning empty strings after cleaning
                 return completionText !== "" ? completionText : null;
            } else {
                console.warn("AI response format unexpected or 'content' field missing/empty:", data);
                return null;
            }
        } catch (error) {
            console.error("Fetch AI Completion failed:", error);
            // Rethrow a more user-friendly error or specific error type
            throw new Error(`Could not reach AI server or process response: ${error.message}`);
        }
    }

    /** Triggers the AI completion process. */
    async function triggerAICompletion() {
        if (!editor) return; // No editor instance

        if (isAICompleting) {
            setStatusMessage("AI is already working...", true, 2000);
            return;
        }
        if (currentFileIndex < 0) {
            setStatusMessage("Open a file to use AI Completion", true, STATUS_MESSAGE_DURATION);
            return;
        }
        if (editor.getOption("readOnly")) {
             setStatusMessage("Cannot complete in read-only state", true, STATUS_MESSAGE_DURATION);
            return;
        }

        clearActiveSuggestion(false); // Clear any previous suggestion
        isAICompleting = true; // Set busy flag

        try {
            const cursor = editor.getCursor();
            // Define context window: current line + N previous lines
            const contextLines = 15;
            const startLine = Math.max(0, cursor.line - contextLines);
            const textBeforeCursor = editor.getRange(CodeMirror.Pos(startLine, 0), cursor);
            const promptText = textBeforeCursor.slice(-AI_PROMPT_MAX_CHARS); // Limit prompt size

            const completion = await fetchAICompletion(promptText);

            if (completion) { // Ensure completion is not null or empty string
                const from = cursor;
                isInsertingAISuggestion = true; // Flag to ignore 'change' event temporarily
                let marker;

                editor.operation(() => {
                    // Insert the completion text
                    editor.replaceRange(completion, from, from, "+AICompletion"); // Use specific origin
                    const to = editor.getCursor(); // Position after insertion

                    // Create the suggestion marker *only* if text was actually inserted
                    if (CodeMirror.cmpPos(from, to) < 0) {
                         marker = editor.markText(from, to, { className: 'cm-ai-suggestion' });
                         activeSuggestionMarker = marker; // Store reference

                         // Handle marker being cleared externally (e.g., by other CodeMirror actions)
                         marker.on('clear', () => {
                             if (activeSuggestionMarker && activeSuggestionMarker.id === marker.id) {
                                 console.log(`Suggestion marker ${marker.id} cleared externally.`);
                                 activeSuggestionMarker = null; // Ensure state is reset
                             }
                         });
                         setStatusMessage("AI Suggestion: Tab=Accept, Esc=Dismiss", false); // Persistent message until dismissed
                         console.log("AI Suggestion displayed:", completion);
                     } else {
                          console.warn("AI Completion resulted in no change, range was zero. Not marking.");
                          setStatusMessage("AI returned no useful completion", false, STATUS_MESSAGE_DURATION);
                     }
                });
            } else {
                console.warn("Completion was empty or null after processing.");
                setStatusMessage("AI returned no completion", false, STATUS_MESSAGE_DURATION);
            }
        } catch (error) {
            console.error("AI Completion Error:", error);
            setStatusMessage(`AI Error: ${error.message}`, true, 5000);
            clearActiveSuggestion(false); // Ensure suggestion is cleared on error
        } finally {
            isAICompleting = false; // Clear busy flag
            isInsertingAISuggestion = false; // Reset insertion flag
            // If status is still "AI thinking...", reset it (covers cases where no suggestion was shown)
            if (dom.statusMessage && dom.statusMessage.textContent === "AI thinking...") {
                setStatusMessage(STATUS_MESSAGE_DEFAULT);
            }
        }
    }


    // --- Language Selection ---

    /** Populates the language selection submenu. */
    function populateLanguageMenu() {
        if (!dom.languageSubmenu) {
            console.error("Language submenu element not found.");
            return;
        }
        const parentLi = dom.languageSubmenu.closest('.menu-item');
         if (!parentLi) {
            console.error("Parent menu item for language submenu not found.");
            return;
         }
        dom.languageSubmenu.innerHTML = ''; // Clear existing options

        const options = dom.languageSelect.options;
        for (let i = 0; i < options.length; i++) {
            const option = options[i];
            const li = document.createElement('li');
            li.className = 'submenu-item language-option';
            li.textContent = option.text; // Display text (e.g., "JavaScript")
            li.dataset.langValue = option.value; // Store CodeMirror mode value (e.g., "javascript")

            li.onclick = (e) => {
                e.stopPropagation(); // Prevent parent menu closing immediately
                if (currentFileIndex >= 0) { // Only allow changing if a file is active
                    setFileLanguage(option.value);
                }
                // Manually close the menu hierarchy by blurring focus/focusing editor
                if (editor) editor.focus();
            };
            dom.languageSubmenu.appendChild(li);
        }
        updateLanguageMenuSelection(); // Set initial checkmark state
    }

    /** Sets the language mode for the current file and updates the editor. */
    function setFileLanguage(newLang, calledDuringSave = false) {
        if (!editor || currentFileIndex < 0 || !files[currentFileIndex]) return; // Guard conditions

        const file = files[currentFileIndex];
        if (file.language === newLang) return; // No change needed

        clearActiveSuggestion(false); // Clear suggestion when changing language

        file.language = newLang;
        editor.setOption("mode", newLang);
        editor.setOption("lint", LINTABLE_MODES.includes(newLang)); // Update linting option

        console.log(`Set language to ${newLang}. Linting: ${editor.getOption("lint")}`);

        const langOption = dom.languageSelect.querySelector(`option[value="${newLang}"]`);
        const langName = langOption ? langOption.text : newLang;
        setStatusMessage(`Language set to ${langName}`, false, STATUS_MESSAGE_DURATION);

        // Mark file as unsaved unless this change happened as part of a save operation
        // (where the language was inferred from the new filename)
        if (!calledDuringSave) {
            file.unsaved = true;
        }

        updateUIForFileStatus(); // Update status bar, save buttons, menu checkmark, etc.
    }

    /** Updates the checkmark indicator in the language selection submenu. */
    function updateLanguageMenuSelection() {
        if (!dom.languageSubmenu) return;
        const items = dom.languageSubmenu.querySelectorAll('.language-option');
        const currentLang = (currentFileIndex >= 0 && files[currentFileIndex]) ? files[currentFileIndex].language : null;

        items.forEach(item => {
            const langValue = item.dataset.langValue;
            // Get the original display text from the hidden select for consistency
            const optionEl = dom.languageSelect.querySelector(`option[value="${langValue}"]`);
            const optionText = optionEl ? optionEl.text : langValue; // Fallback to value

            if (currentLang && langValue === currentLang) {
                item.textContent = `✓ ${optionText}`; // Add checkmark
                item.style.fontWeight = 'bold';
            } else {
                item.textContent = optionText; // Restore original text
                item.style.fontWeight = 'normal';
            }
        });
    }


    // --- Event Handlers ---

    // Menu/Toolbar Action Handlers
    function handleNewFileClick() {
        // Reset modal fields
        dom.newFileNameInput.value = "";
        dom.newFileLangSelect.value = "javascript"; // Default to JS
        openModal(dom.newFileModal);
    }
    function handleOpenFileClick() { openFile(); }
    function handleSaveClick() { if (dom.menuSave.dataset.enabled === 'true') saveFile(false); }
    function handleSaveAsClick() {
        if (dom.menuSaveAs.dataset.enabled === 'true') {
            // Pre-fill filename if a file is open
            if (currentFileIndex >= 0 && files[currentFileIndex]) {
                dom.saveAsFileNameInput.value = files[currentFileIndex].name;
            } else {
                dom.saveAsFileNameInput.value = ""; // Should not happen if menu item disabled correctly
            }
            openModal(dom.saveAsModal);
        }
    }
    function handleCloseFileClick() { if (dom.menuCloseFile.dataset.enabled === 'true' && currentFileIndex >= 0) removeFile(currentFileIndex); }
    function handleUndoMenuClick() { if (editor && dom.menuUndo.dataset.enabled === 'true') editor.undo(); }
    function handleRedoMenuClick() { if (editor && dom.menuRedo.dataset.enabled === 'true') editor.redo(); }
    function handleFindMenuClick() { toggleFindReplace(true); }
    function handleAICompleteMenuClick() { triggerAICompletion(); }
    function handleToggleLineNumbersClick() { if (editor) editor.setOption("lineNumbers", !editor.getOption("lineNumbers")); }
    function handleToggleWrappingClick() { if (editor) editor.setOption("lineWrapping", !editor.getOption("lineWrapping")); }

    // Find/Replace Bar Handlers
    function handleFindPrevClick() { find(true); }
    function handleFindNextClick() { find(false); }
    function handleReplaceClick() { replace(); }
    function handleReplaceAllClick() { replaceAll(); }
    function handleCloseFindClick() { toggleFindReplace(false); }
    function handleFindInputKeydown(e) {
        if (e.key === 'Enter') { e.preventDefault(); find(e.shiftKey); } // Shift+Enter = Find Prev
        else if (e.key === 'Escape') { toggleFindReplace(false); }
    }
     function handleReplaceInputKeydown(e) {
        if (e.key === 'Enter') { e.preventDefault(); replace(); } // Enter = Replace then Find Next
        else if (e.key === 'Escape') { toggleFindReplace(false); }
    }

    // Modal Button Handlers
    function handleCreateNewFileConfirm() {
        const name = dom.newFileNameInput.value.trim();
        const lang = dom.newFileLangSelect.value;
        let finalName = name;

        // Append suggested extension if none provided and name is not empty
        if (name && name.indexOf('.') === -1) {
            finalName = name + getSuggestedExtension(lang);
        }
        // Re-check language based on final name (user might have typed an extension)
        const finalLang = getLanguageFromFileName(finalName);

        if (createNewFileEntry(finalName, finalLang)) { // Use the helper function
            closeModal(dom.newFileModal);
        } else {
            // Keep modal open on failure (e.g., empty name, duplicate)
            if (!name) dom.newFileNameInput.focus(); // Focus name input if it was empty
        }
    }
    function handleSaveAsConfirm() { saveFile(true); } // Save As confirm calls saveFile directly

    // CodeMirror Key Handlers (defined in initEditor, linked here for clarity)
    function handleEscapeKey(cm) {
         // 1. Clear active AI suggestion
         if (activeSuggestionMarker) {
            clearActiveSuggestion(false); // Reject suggestion
            return; // Stop further Esc processing
         }
         // 2. Close Find/Replace bar
         if (dom.findReplaceContainer.style.display !== 'none') {
            toggleFindReplace(false);
            return; // Stop further Esc processing
         }
        // 3. Close any open menu submenus (by focusing editor)
        const openMenus = document.querySelectorAll('.menu-item:hover > ul.submenu');
        if (openMenus.length > 0) {
             if (editor) editor.focus();
             return;
        }
         // 4. Close active Lint tooltips
        const lintTooltips = document.querySelectorAll('.CodeMirror-lint-tooltip');
        let closedTooltip = false;
        lintTooltips.forEach(tip => {
            if (tip && tip.parentNode) { tip.parentNode.removeChild(tip); closedTooltip = true; }
        });
        if (closedTooltip) return;

        // 5. Close any active modal
        const openModalEl = document.querySelector('.modal.active');
        if (openModalEl) {
             closeModal(openModalEl);
             return;
        }

        // If none of the above handled Esc, pass it to CodeMirror default behavior (if any)
        return CodeMirror.Pass;
    }

    function handleTabKey(cm) {
        if (activeSuggestionMarker) {
            clearActiveSuggestion(true); // Accept suggestion
            return; // Prevent default Tab behavior
        }
        // If no suggestion, let CodeMirror handle Tab (indentation, etc.)
        return CodeMirror.Pass;
    }

    // Browser Event Handlers
    function handleBeforeUnload(event) {
        const hasUnsaved = files.some(file => file.unsaved);
        if (hasUnsaved) {
            const msg = 'You have unsaved changes. Are you sure you want to leave?';
            event.preventDefault(); // Standard way to trigger confirmation dialog
            event.returnValue = msg; // For older browsers
            return msg; // For some modern browsers
        }
        // No confirmation needed if no unsaved changes
    }

    function handleModalBackdropClick(event) {
        // Close modal if the click is directly on the modal backdrop (the .modal element)
         if (event.target.classList.contains('modal') && event.target.classList.contains('active')) {
             closeModal(event.target);
         }
    }

    // --- Event Listener Setup ---
    function setupEventListeners() {
        // Toolbar Buttons
        document.getElementById("toolbar-new").addEventListener("click", handleNewFileClick);
        document.getElementById("toolbar-open").addEventListener("click", handleOpenFileClick);
        document.getElementById("toolbar-save").addEventListener("click", handleSaveClick);
        document.getElementById("toolbar-find").addEventListener("click", handleFindMenuClick); // Reuse menu handler

        // Menu Items
        document.getElementById("menu-new").addEventListener("click", handleNewFileClick);
        document.getElementById("menu-open").addEventListener("click", handleOpenFileClick);
        document.getElementById("menu-save").addEventListener("click", handleSaveClick);
        document.getElementById("menu-saveas").addEventListener("click", handleSaveAsClick);
        document.getElementById("menu-closefile").addEventListener("click", handleCloseFileClick);
        document.getElementById("menu-undo").addEventListener("click", handleUndoMenuClick);
        document.getElementById("menu-redo").addEventListener("click", handleRedoMenuClick);
        document.getElementById("menu-find").addEventListener("click", handleFindMenuClick);
        document.getElementById("menu-ai-complete").addEventListener("click", handleAICompleteMenuClick);
        document.getElementById("menu-toggle-linenumbers").addEventListener("click", handleToggleLineNumbersClick);
        document.getElementById("menu-toggle-wrapping").addEventListener("click", handleToggleWrappingClick);

        // Find/Replace Bar Elements
        document.getElementById("findPrevBtn").addEventListener("click", handleFindPrevClick);
        document.getElementById("findNextBtn").addEventListener("click", handleFindNextClick);
        document.getElementById("replaceBtn").addEventListener("click", handleReplaceClick);
        document.getElementById("replaceAllBtn").addEventListener("click", handleReplaceAllClick);
        document.getElementById("closeFindBtn").addEventListener("click", handleCloseFindClick);
        dom.findInput.addEventListener('keydown', handleFindInputKeydown);
        dom.replaceInput.addEventListener('keydown', handleReplaceInputKeydown);

        // Modal Elements & Buttons
        document.getElementById("closeNewFileModal").addEventListener("click", () => closeModal(dom.newFileModal));
        document.getElementById("cancelNewFile").addEventListener("click", () => closeModal(dom.newFileModal));
        document.getElementById("createNewFile").addEventListener("click", handleCreateNewFileConfirm);
        document.getElementById("closeSaveAsModal").addEventListener("click", () => closeModal(dom.saveAsModal));
        document.getElementById("cancelSaveAs").addEventListener("click", () => closeModal(dom.saveAsModal));
        document.getElementById("confirmSaveAs").addEventListener("click", handleSaveAsConfirm);

        // Modal Enter Keypress (Submit on Enter)
        dom.newFileNameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleCreateNewFileConfirm(); });
        dom.newFileLangSelect.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleCreateNewFileConfirm(); });
        dom.saveAsFileNameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleSaveAsConfirm(); });

        // Global Event Listeners
        window.addEventListener('beforeunload', handleBeforeUnload);
        window.addEventListener('click', handleModalBackdropClick); // Listener for closing modals on backdrop click
    }

    // --- App Entry Point ---
    document.addEventListener('DOMContentLoaded', initApp);

})(); // End IIFE
</script>
</body>
</html>
